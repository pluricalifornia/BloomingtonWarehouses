<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>Bloomington Warehouse Pollution Export Network Map</title>
    
    <link rel="stylesheet" href="https://js.arcgis.com/4.27/esri/themes/light/main.css">
    <style>
        html, body, #viewDiv {
            padding: 0;
            margin: 0;
            height: 100%;
            width: 100%;
        }
        
        #infoPanel {
            position: absolute;
            top: 15px;
            right: 15px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 99;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        
        .legend-line {
            width: 30px;
            height: 3px;
            margin-right: 10px;
        }
        
        .legend-circle {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
            border: 2px solid white;
            box-shadow: 0 0 2px rgba(0,0,0,0.3);
        }
        
        .node-info {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #ddd;
        }
        
        .warehouse-details {
            background: #f5f5f5;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 13px;
        }
        
        .pollution-stats {
            background: #ffe6e6;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            border-left: 4px solid #e74c3c;
            font-size: 12px;
        }
        
        .pollution-export {
            background: #fff3cd;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            border-left: 4px solid #f39c12;
            font-size: 12px;
        }
        
        .mind-map-branch {
            margin: 10px 0;
            padding: 10px;
            background: #f9f9f9;
            border-left: 4px solid #3498db;
            border-radius: 4px;
        }
        
        .branch-title {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .branch-details {
            font-size: 12px;
            color: #555;
            margin: 5px 0;
        }
        
        #loadingDiv {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        
        #errorDiv {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            display: none;
            max-width: 400px;
        }
        
        .stats-section {
            background: #e8f4f8;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-size: 13px;
        }
        
        .pollution-overview {
            background: #ffeaa7;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            border-left: 5px solid #f39c12;
        }
        
        .pollution-overview h4 {
            margin: 0 0 10px 0;
            color: #e17055;
            font-size: 16px;
        }
        
        .pollution-metric {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 12px;
        }
        
        .pollution-metric strong {
            color: #2d3436;
        }
        
        .warehouse-node-legend {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #ddd;
        }
        
        .tree-structure {
            margin-left: 15px;
            border-left: 2px solid #ddd;
            padding-left: 10px;
        }
        
        .tree-node {
            margin: 5px 0;
            position: relative;
        }
        
        #controlPanel {
            position: absolute;
            top: 15px;
            left: 15px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 99;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .control-button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: background 0.3s;
        }
        
        .control-button:hover {
            background: #2980b9;
        }
        
        .control-button.secondary {
            background: #95a5a6;
        }
        
        .control-button.secondary:hover {
            background: #7f8c8d;
        }
        
        .control-button.toggle-hint {
            background: #e74c3c;
            font-size: 12px;
            padding: 5px 10px;
        }
        
        .control-button.toggle-hint:hover {
            background: #c0392b;
        }
        
        .pollution-flow {
            animation: pollutionPulse 3s infinite;
        }
        
        @keyframes pollutionPulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1.0; }
        }
        
        .high-pollution-node {
            animation: dangerPulse 2s infinite;
        }
        
        @keyframes dangerPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://js.arcgis.com/4.27/"></script>
</head>
<body>
    <div id="controlPanel">
        <button class="control-button" onclick="resetCacheAndReload()">Reset Cache & Reload</button>
        <button class="control-button secondary" onclick="expandAll()">Expand All</button>
        <button class="control-button secondary" onclick="collapseAll()">Collapse All</button>
        <button class="control-button toggle-hint" onclick="togglePollutionView()">Toggle Pollution View</button>
        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #ddd;">
            <small style="color: #666;">
                <strong>Click</strong> node to expand/collapse<br>
                <strong>Shift+Click</strong> for info only
            </small>
        </div>
    </div>
    <div id="viewDiv"></div>
    <div id="loadingDiv">
        <h3>Loading Pollution Export Network...</h3>
        <p>Processing warehouse ownership and pollution data</p>
    </div>
    <div id="errorDiv">
        <h3>Error Loading Data</h3>
        <p id="errorMessage"></p>
    </div>
    <div id="infoPanel" style="display: none;">
        <h3>Pollution Export Network</h3>
        <p><strong>Bloomington, CA</strong> - Environmental Justice Analysis</p>
        
        <div class="pollution-overview">
            <h4>🚨 Daily Pollution Impact</h4>
            <div class="pollution-metric">
                <span>Truck Trips:</span>
                <strong>3,000 daily</strong>
            </div>
            <div class="pollution-metric">
                <span>Diesel PM:</span>
                <strong>4.1 lbs/day</strong>
            </div>
            <div class="pollution-metric">
                <span>NOx:</span>
                <strong>467 lbs/day</strong>
            </div>
            <div class="pollution-metric">
                <span>CO2:</span>
                <strong>126.2 tons/day</strong>
            </div>
            <div style="margin-top: 10px; font-size: 11px; color: #636e72;">
                <em>Pollution concentrated in low-income Bloomington while profits flow to wealthy areas</em>
            </div>
        </div>
        
        <div class="stats-section" id="statsSection">
            <!-- Stats will be populated dynamically -->
        </div>
        
        <div class="legend">
            <h4>Entity Types</h4>
            <div class="legend-item">
                <div class="legend-circle" style="background: #e74c3c; animation: pollutionPulse 2s infinite;"></div>
                <span>Pollution Sink (Bloomington)</span>
            </div>
            <div class="legend-item">
                <div class="legend-circle" style="background: #8B4513;"></div>
                <span>Warehouse Property</span>
            </div>
            <div class="legend-item">
                <div class="legend-circle" style="background: #2E86C1;"></div>
                <span>Developer (Wealth Source)</span>
            </div>
            <div class="legend-item">
                <div class="legend-circle" style="background: #f39c12;"></div>
                <span>Owner/Purchaser (Wealth Source)</span>
            </div>
            <div class="legend-item">
                <div class="legend-circle" style="background: #27AE60;"></div>
                <span>Leasee/Tenant</span>
            </div>
            <div class="legend-item">
                <div class="legend-circle" style="background: #3498DB;"></div>
                <span>Headquarters Location</span>
            </div>
        </div>
        
        <div class="warehouse-node-legend">
            <h4>Pollution Flow Types</h4>
            <div class="legend-item">
                <div class="legend-line" style="background: linear-gradient(90deg, #e74c3c, #d63031); width: 4px; animation: pollutionPulse 3s infinite;"></div>
                <span>Heavy Pollution Export</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #8B4513; width: 4px;"></div>
                <span>Contains Warehouse</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #2E86C1; width: 4px;"></div>
                <span>Profit Flow (Development)</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #f39c12; width: 4px;"></div>
                <span>Profit Flow (Ownership)</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #27AE60; width: 3px;"></div>
                <span>Leased Operations</span>
            </div>
        </div>
        
        <div class="node-info" id="nodeInfo">
            <p>Click on nodes for details</p>
        </div>
    </div>

    <script>
        // GitHub repository URLs
        const githubBaseUrl = "https://raw.githubusercontent.com/pluricalifornia/BloomingtonWarehouses/main/";
        const csvUrl = githubBaseUrl + "data/WarehouseTracker.csv";
        const geoJsonUrl = githubBaseUrl + "data/warehouses%20(1).geojson";
        
        // Pollution data - embedded from the CSV
        const pollutionData = {
            dailyTruckTrips: 3000,
            dailyDieselPM: 4.1, // pounds
            dailyNOx: 467, // pounds  
            dailyCO2: 126.2 // metric tons
        };
        
        // Cache management
        let dataCache = {
            csv: null,
            geoJson: null,
            timestamp: null
        };
        
        // Global variables for visualization
        let networkView = null;
        let collapsedNodes = new Set();
        let allNodes = {};
        let allEdges = [];
        let nodeLayer = null;
        let edgeLayer = null;
        let labelLayer = null;
        let pollutionLayer = null;
        let showPollutionView = true;
        
        // Helper function to convert hex to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [
                parseInt(result[1], 16),
                parseInt(result[2], 16),
                parseInt(result[3], 16)
            ] : [128, 128, 128];
        }
        
        // Helper function to convert hex to RGBA
        function hexToRgba(hex, alpha) {
            const rgb = hexToRgb(hex);
            return [...rgb, alpha];
        }
        
        // Calculate pollution export based on warehouse square footage and entity responsibility
        function calculatePollutionExport(entityType, warehouseSqft, totalSqft, entityWarehouseData) {
            // Calculate the proportion of total warehouse space this entity is responsible for
            const sqftProportion = warehouseSqft / totalSqft;
            
            // Base responsibility multiplier based on entity type
            const typeMultipliers = {
                'developer': 0.3, // Developers contribute to initial infrastructure
                'purchaser': 0.6, // Purchasers/owners have primary responsibility 
                'leasee': 0.1    // Leasees have operational impact
            };
            
            const responsibilityMultiplier = typeMultipliers[entityType] || 0.3;
            
            // Calculate this entity's share of total pollution based on their warehouse sqft
            const pollutionShare = sqftProportion * responsibilityMultiplier;
            
            return {
                truckTrips: Math.round(pollutionData.dailyTruckTrips * pollutionShare),
                dieselPM: parseFloat((pollutionData.dailyDieselPM * pollutionShare).toFixed(2)),
                nox: Math.round(pollutionData.dailyNOx * pollutionShare),
                co2: parseFloat((pollutionData.dailyCO2 * pollutionShare).toFixed(1)),
                sqftProportion: (sqftProportion * 100).toFixed(1),
                warehouseSqft: warehouseSqft.toLocaleString()
            };
        }
        
        // Calculate distance between two coordinates in miles
        function calculateDistance(coord1, coord2) {
            const R = 3959; // Earth's radius in miles
            const dLat = (coord2[1] - coord1[1]) * Math.PI / 180;
            const dLon = (coord2[0] - coord1[0]) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(coord1[1] * Math.PI / 180) * Math.cos(coord2[1] * Math.PI / 180) *
                    Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        // Function to toggle pollution view
        window.togglePollutionView = function() {
            showPollutionView = !showPollutionView;
            updateNetworkVisualization();
        }
        
        // Function to reset cache and reload
        window.resetCacheAndReload = function() {
            dataCache = {
                csv: null,
                geoJson: null,
                timestamp: null
            };
            console.log("Cache cleared. Reloading page...");
            location.reload();
        }
        
        // Function to expand all nodes
        window.expandAll = function() {
            collapsedNodes.clear();
            updateNetworkVisualization();
        }
        
        // Function to collapse all nodes
        window.collapseAll = function() {
            Object.entries(allNodes).forEach(([nodeId, node]) => {
                if (node.type === 'warehouse') {
                    collapsedNodes.add(nodeId);
                }
            });
            updateNetworkVisualization();
        }
        
        // Function to toggle node expansion
        window.toggleNodeExpansion = function(nodeId) {
            if (collapsedNodes.has(nodeId)) {
                collapsedNodes.delete(nodeId);
            } else {
                collapsedNodes.add(nodeId);
            }
            updateNetworkVisualization();
        }
        
        // Function to check if a node should be visible
        function isNodeVisible(nodeId, nodes, edges) {
            const node = nodes[nodeId];
            if (!node) return false;
            
            if (node.type === 'root') return true;
            
            const ancestors = getNodeAncestors(nodeId, edges);
            for (const ancestorId of ancestors) {
                if (collapsedNodes.has(ancestorId)) {
                    return false;
                }
            }
            
            return true;
        }
        
        // Function to get all ancestors of a node
        function getNodeAncestors(nodeId, edges) {
            const ancestors = [];
            let currentId = nodeId;
            
            while (currentId) {
                const parentEdge = edges.find(e => e.to === currentId);
                if (parentEdge) {
                    ancestors.push(parentEdge.from);
                    currentId = parentEdge.from;
                } else {
                    break;
                }
            }
            
            return ancestors;
        }
        
        // Function to check if a node has children
        function hasChildNodes(nodeId) {
            return allEdges.some(edge => edge.from === nodeId);
        }
        
        // Function to count direct children of a node
        function countDirectChildren(nodeId) {
            return allEdges.filter(edge => edge.from === nodeId).length;
        }
        
        // Function to count collapsed children
        function countCollapsedChildren(nodeId, nodes, edges) {
            let count = 0;
            const children = edges.filter(e => e.from === nodeId).map(e => e.to);
            
            children.forEach(childId => {
                if (!isNodeVisible(childId, nodes, edges)) {
                    count++;
                }
                count += countCollapsedChildren(childId, nodes, edges);
            });
            
            return count;
        }
        
        // Function to update network visualization based on collapsed state
        function updateNetworkVisualization() {
            if (!networkView || !nodeLayer || !edgeLayer || !labelLayer || !window.ArcGISModules) return;
            
            const { Point, Polyline, Graphic, SimpleMarkerSymbol, SimpleLineSymbol, TextSymbol } = window.ArcGISModules;
            
            nodeLayer.removeAll();
            edgeLayer.removeAll();
            labelLayer.removeAll();
            if (pollutionLayer) pollutionLayer.removeAll();
            
            const bloomingtonCoords = [-117.396, 34.070];
            
            // Redraw edges with pollution visualization
            allEdges.forEach(edge => {
                const fromVisible = isNodeVisible(edge.from, allNodes, allEdges);
                const toVisible = isNodeVisible(edge.to, allNodes, allEdges);
                
                if (fromVisible && toVisible) {
                    const fromNode = allNodes[edge.from];
                    const toNode = allNodes[edge.to];
                    
                    if (fromNode && toNode) {
                        const polyline = new Polyline({
                            paths: [[fromNode.coords, toNode.coords]],
                            spatialReference: { wkid: 4326 }
                        });
                        
                        let color, width, style;
                        
                        if (showPollutionView && toNode.type === "root" && fromNode.type === "entity") {
                            const distance = calculateDistance(fromNode.coords, bloomingtonCoords);
                            const pollutionAmount = fromNode.pollutionExport || {};
                            
                            color = [231, 76, 60, 0.9];
                            width = Math.max(3, Math.min(8, (pollutionAmount.truckTrips || 0) / 50));
                            style = "solid";
                            
                            edge.pollutionExport = pollutionAmount;
                            edge.distance = distance.toFixed(1);
                        } else if (edge.type === "contains" && fromNode.type === "root") {
                            color = [139, 69, 19, 0.8];
                            width = 4;
                            style = "solid";
                        } else if (edge.type === "contains") {
                            color = edge.color ? hexToRgba(edge.color, 0.6) : [149, 165, 166, 0.6];
                            width = 2;
                            style = "solid";
                        } else if (edge.type === "developer") {
                            color = showPollutionView ? [46, 134, 193, 0.9] : [46, 134, 193, 0.8];
                            width = showPollutionView ? 4 : 3;
                            style = "solid";
                        } else if (edge.type === "purchaser") {
                            color = showPollutionView ? [243, 156, 18, 0.9] : [231, 76, 60, 0.8];
                            width = showPollutionView ? 4 : 3;
                            style = "solid";
                        } else if (edge.type === "leasee") {
                            color = [39, 174, 96, 0.8];
                            width = 3;
                            style = "solid";
                        } else {
                            color = [149, 165, 166, 0.8];
                            width = 2;
                            style = "dash";
                        }
                        
                        const lineSymbol = new SimpleLineSymbol({
                            color: color,
                            width: width,
                            style: style
                        });
                        
                        const graphic = new Graphic({
                            geometry: polyline,
                            symbol: lineSymbol,
                            attributes: edge
                        });
                        
                        edgeLayer.add(graphic);
                    }
                }
            });
            
            // Redraw nodes with pollution impact visualization
            Object.entries(allNodes).forEach(([nodeId, node]) => {
                if (isNodeVisible(nodeId, allNodes, allEdges)) {
                    const point = new Point({
                        longitude: node.coords[0],
                        latitude: node.coords[1],
                        spatialReference: { wkid: 4326 }
                    });
                    
                    let size = 10;
                    let color = hexToRgb(node.color || "#999999");
                    let outline = { color: [255, 255, 255], width: 2 };
                    
                    if (node.type === "root") {
                        size = showPollutionView ? 28 : 24;
                        color = showPollutionView ? [231, 76, 60] : hexToRgb(node.color);
                        outline = { color: [128, 0, 0], width: 3 };
                    } else if (node.type === "warehouse") {
                        size = 16;
                    } else if (node.type === "relationship") {
                        size = 8;
                    } else if (node.type === "entity") {
                        if (showPollutionView && node.subtype && node.pollutionExport) {
                            const pollutionAmount = node.pollutionExport;
                            
                            size = 12 + Math.min(node.connections * 2, 8) + (pollutionAmount.truckTrips / 100);
                            
                            if (pollutionAmount.truckTrips > 200) {
                                color = [139, 0, 0];
                                outline = { color: [69, 0, 0], width: 3 };
                            } else if (pollutionAmount.truckTrips > 100) {
                                color = [220, 53, 69];
                                outline = { color: [139, 0, 0], width: 3 };
                            } else if (pollutionAmount.truckTrips > 50) {
                                color = [255, 107, 107];
                                outline = { color: [231, 76, 60], width: 2 };
                            } else if (pollutionAmount.truckTrips > 10) {
                                color = [255, 193, 7];
                                outline = { color: [243, 156, 18], width: 2 };
                            } else {
                                color = hexToRgb(node.color);
                            }
                        } else {
                            size = 12 + Math.min(node.connections * 2, 8);
                        }
                    }
                    
                    const collapsedChildCount = countCollapsedChildren(nodeId, allNodes, allEdges);
                    const hasCollapsedChildren = collapsedNodes.has(nodeId) || collapsedChildCount > 0;
                    const hasChildren = countDirectChildren(nodeId) > 0;
                    
                    if (hasCollapsedChildren) {
                        outline = { color: [231, 76, 60], width: 3 };
                    }
                    
                    const markerSymbol = new SimpleMarkerSymbol({
                        color: color,
                        size: size,
                        outline: outline
                    });
                    
                    const graphic = new Graphic({
                        geometry: point,
                        symbol: markerSymbol,
                        attributes: {
                            ...node,
                            nodeId: nodeId,
                            collapsedChildCount: collapsedChildCount
                        }
                    });
                    
                    nodeLayer.add(graphic);
                    
                    // Add labels for important nodes
                    if (node.type === "root" || node.type === "warehouse" || 
                        (node.type === "entity" && node.connections > 0)) {
                        let labelText = node.name;
                        if (node.type === "warehouse") {
                            labelText = node.id && node.id.length > 10 ? "WH" : (node.id || node.name);
                        }
                        
                        if (collapsedChildCount > 0) {
                            labelText += ` (${collapsedChildCount})`;
                        }
                        
                        if (showPollutionView && node.type === "entity" && node.subtype && node.pollutionExport) {
                            const pollutionAmount = node.pollutionExport;
                            if (pollutionAmount.truckTrips > 200) {
                                labelText += " 🚨🚨";
                            } else if (pollutionAmount.truckTrips > 100) {
                                labelText += " 🚨";
                            } else if (pollutionAmount.truckTrips > 50) {
                                labelText += " ⚠️";
                            } else if (pollutionAmount.truckTrips > 10) {
                                labelText += " ⚡";
                            }
                        }
                        
                        const textSymbol = new TextSymbol({
                            text: labelText,
                            color: [0, 0, 0],
                            haloColor: [255, 255, 255],
                            haloSize: 2,
                            font: {
                                size: node.type === "root" ? 14 : 
                                      (node.type === "warehouse" ? 9 : 10),
                                weight: node.type === "root" ? "bold" : "normal"
                            },
                            yoffset: -18
                        });
                        
                        const labelGraphic = new Graphic({
                            geometry: point,
                            symbol: textSymbol
                        });
                        
                        labelLayer.add(labelGraphic);
                    }
                }
            });
        }
        
        // Function to ensure APN format consistency
        function normalizeAPN(apn) {
            if (!apn) return apn;
            
            let apnStr = String(apn).trim();
            
            if (/^\d+$/.test(apnStr) && apnStr.length < 9) {
                apnStr = apnStr.padStart(9, '0');
            }
            
            return apnStr;
        }
        
        // Fallback embedded data for testing
        const fallbackCsvData = `"Category","Assessor parcel number","Building classification","Year built/approved","Acres","Building sq.ft.",Developer,DevOriginCity,Purchaser/Merger,Category,Leasee,PurchaserOriginCity,LeaseeOriginCity,Endpoint
"Approved","Bloomington Business Park","https://ceqanet.opr.ca.gov/2020120545/3","2025","181","4340000",Howard Industrial Partners LLC,"Lemon Heights, CA",TBD,TBD,TBD,TBD,TBD,"Bloomington, CA"
"Existing","025217367","transit warehouse (truck terminal)","2001","47","1133000",Pacific Industrial,"Newport Beach, CA",Realterm,Purchase,YellowCorp,"Annapolis, MD",TBD,"Bloomington, CA"
"Existing","Bloomington Logistics Center","distribution warehouse","2019","35","827000", Crow holdings Industrial, "Highland Park, TX", ASB Real Estate Investments,Purchase,TBD,"Bethseda, MD",TBD,"Bloomington, CA"
"Existing","025215217","distribution warehouse","2018","28","674000", DCT Industrial Trust,"Evergreen, CO",Prologis,Merger,TBD,"Pacific Heights, CA",TBD,"Bloomington, CA"`;

        require([
            "esri/Map",
            "esri/views/MapView",
            "esri/Graphic",
            "esri/layers/GraphicsLayer",
            "esri/geometry/Point",
            "esri/geometry/Polygon",
            "esri/geometry/Polyline",
            "esri/symbols/SimpleMarkerSymbol",
            "esri/symbols/SimpleFillSymbol",
            "esri/symbols/SimpleLineSymbol",
            "esri/symbols/TextSymbol",
            "esri/rest/locator",
            "esri/widgets/Popup"
        ], function(Map, MapView, Graphic, GraphicsLayer, Point, Polygon, Polyline, 
                   SimpleMarkerSymbol, SimpleFillSymbol, SimpleLineSymbol, TextSymbol, locator, Popup) {

            // Store modules globally for use outside require block
            window.ArcGISModules = {
                Point, Polyline, Graphic, SimpleMarkerSymbol, SimpleLineSymbol, TextSymbol
            };

            // Cache for geocoded locations
            const geocodeCache = {};
            
            // Predefined coordinates for known cities
            const cityCoords = {
                "Bloomington, CA": [-117.396, 34.070],
                "Lemon Heights, CA": [-117.823, 33.765],
                "Newport Beach, CA": [-117.928, 33.618],
                "Annapolis, MD": [-76.492, 38.978],
                "Highland Park, TX": [-96.792, 32.834],
                "Bethesda, MD": [-77.094, 38.984],
                "Bethseda, MD": [-77.094, 38.984], // Handle typo
                "Evergreen, CO": [-105.321, 39.633],
                "Pacific Heights, CA": [-122.447, 37.794],
                "San Francisco, CA": [-122.419, 37.774],
                "Denver, CO": [-104.990, 39.739],
                "Irvine, CA": [-117.826, 33.684],
                "Costa Mesa, CA": [-117.919, 33.641]
            };

            // Function to get centroid of a polygon
            function getPolygonCentroid(coordinates) {
                let sumX = 0, sumY = 0, count = 0;
                
                if (coordinates.length > 0 && Array.isArray(coordinates[0][0][0])) {
                    coordinates.forEach(polygon => {
                        polygon.forEach(ring => {
                            ring.forEach(coord => {
                                sumX += coord[0];
                                sumY += coord[1];
                                count++;
                            });
                        });
                    });
                } else {
                    coordinates.forEach(ring => {
                        ring.forEach(coord => {
                            sumX += coord[0];
                            sumY += coord[1];
                            count++;
                        });
                    });
                }
                
                return [sumX / count, sumY / count];
            }

            // Get warehouse position from GeoJSON or generate one
            function getWarehousePositionFromGeoJson(apn, geoJsonByApn, index, total) {
                const normalizedApn = normalizeAPN(apn);
                const feature = geoJsonByApn[normalizedApn] || geoJsonByApn[apn];
                
                if (feature && feature.geometry) {
                    return getPolygonCentroid(feature.geometry.coordinates);
                }
                
                const bloomingtonCoords = cityCoords["Bloomington, CA"];
                const radius = 0.15;
                const angle = (index / total) * 2 * Math.PI;
                
                return [
                    bloomingtonCoords[0] + radius * Math.cos(angle),
                    bloomingtonCoords[1] + radius * Math.sin(angle)
                ];
            }

            // Geocoding function with US bounds checking
            async function geocodeLocation(address) {
                if (geocodeCache[address]) {
                    return geocodeCache[address];
                }
                
                if (cityCoords[address]) {
                    geocodeCache[address] = cityCoords[address];
                    return cityCoords[address];
                }
                
                try {
                    const geocodeUrl = "https://geocode-api.arcgis.com/arcgis/rest/services/World/GeocodeServer";
                    const result = await locator.addressToLocations(geocodeUrl, {
                        address: {
                            SingleLine: address
                        },
                        maxLocations: 1,
                        countryCode: "USA"
                    });
                    
                    if (result && result.length > 0) {
                        const coords = [result[0].location.longitude, result[0].location.latitude];
                        
                        const lon = coords[0];
                        const lat = coords[1];
                        
                        const isInContinentalUS = lon >= -125 && lon <= -66 && lat >= 24 && lat <= 49;
                        const isInAlaska = lon >= -180 && lon <= -130 && lat >= 52 && lat <= 72;
                        const isInHawaii = lon >= -161 && lon <= -154 && lat >= 18 && lat <= 23;
                        
                        if (isInContinentalUS || isInAlaska || isInHawaii) {
                            geocodeCache[address] = coords;
                            return coords;
                        } else {
                            console.warn(`Location ${address} geocoded outside US bounds:`, coords);
                        }
                    }
                } catch (error) {
                    console.warn(`Geocoding failed for ${address}:`, error);
                }
                
                return null;
            }

            // Function to get coordinates with offset for multiple entities
            const entityOffsets = {};
            async function getCoordinatesForEntity(location, entityName) {
                if (!location) return null;
                
                const baseCoords = await geocodeLocation(location);
                if (!baseCoords) return null;
                
                const key = location + "|" + entityName;
                if (!entityOffsets[key]) {
                    const count = Object.keys(entityOffsets).filter(k => k.startsWith(location)).length;
                    const angle = (count * 72) * Math.PI / 180;
                    const offset = 0.05;
                    entityOffsets[key] = [
                        baseCoords[0] + offset * Math.cos(angle),
                        baseCoords[1] + offset * Math.sin(angle)
                    ];
                }
                return entityOffsets[key];
            }

            // Helper functions for data cleaning
            function cleanLocation(location) {
                if (!location || typeof location !== 'string') return null;
                
                let cleaned = location.trim().replace(/["\\"]/g, '').trim();
                
                const invalidLocations = ['TBD', 'TBA', 'N/A', 'CA', 'TX', 'FL', 'NY', 'AZ', 'CO', 'MD', 
                    'Florida', 'Texas', 'California', 'Unknown', '', 'undefined', 'null'];
                if (invalidLocations.includes(cleaned)) return null;
                
                if (/^[A-Z]{2}$/.test(cleaned)) return null;
                
                if (cleaned === 'Bethseda, MD') cleaned = 'Bethesda, MD';
                
                const cityStateMap = {
                    'Highland Park': 'Highland Park, TX',
                    'Miami Beach': 'Miami Beach, FL'
                };
                
                if (cityStateMap[cleaned]) {
                    cleaned = cityStateMap[cleaned];
                }
                
                return cleaned;
            }
            
            function cleanEntityName(name) {
                if (!name || typeof name !== 'string') return null;
                
                let cleaned = name.trim().replace(/["\\"]/g, '').trim();
                
                const invalidNames = ['TBD', 'TBA', 'N/A', 'Purchase', 'Merger', 'Acquisition', 
                    'Joint Venture', 'Partnership', 'Category', '', 'undefined', 'null'];
                if (invalidNames.includes(cleaned)) return null;
                
                if (/^[A-Z]{2}$/.test(cleaned)) return null;
                
                return cleaned;
            }

            // Build mind map data structure with pollution awareness
            function buildMindMapData(parsedData, geoJsonByApn) {
                const mindMapData = {
                    name: "Bloomington, CA",
                    color: "#e74c3c",
                    details: "Pollution sink receiving environmental burden from wealthy areas",
                    type: "root",
                    children: []
                };

                // First pass: calculate total square footage for proper proportional distribution
                let totalSqft = 0;
                const warehouseDataWithSqft = [];
                
                parsedData.forEach((row, index) => {
                    const rawApn = row["Assessor parcel number"];
                    const warehouseId = normalizeAPN(rawApn) || `Warehouse_${index}`;
                    
                    let sqft = parseInt(row["Building sq.ft."]) || 0;
                    
                    const geoJsonFeature = geoJsonByApn[warehouseId] || geoJsonByApn[rawApn];
                    if (geoJsonFeature && geoJsonFeature.properties && geoJsonFeature.properties.shape_area) {
                        if (sqft === 0 || sqft < geoJsonFeature.properties.shape_area) {
                            sqft = geoJsonFeature.properties.shape_area;
                        }
                    }
                    
                    totalSqft += sqft;
                    warehouseDataWithSqft.push({...row, warehouseId, sqft, geoJsonFeature, index});
                });
                
                console.log(`Total warehouse square footage: ${totalSqft.toLocaleString()}`);

                // Second pass: build warehouse nodes with proportional pollution calculations
                warehouseDataWithSqft.forEach((warehouseData) => {
                    const { warehouseId, sqft, geoJsonFeature, index } = warehouseData;
                    const developer = cleanEntityName(warehouseData.Developer);
                    const purchaser = cleanEntityName(warehouseData["Purchaser/Merger"]);
                    const leasee = cleanEntityName(warehouseData.Leasee);
                    
                    let buildingClass = warehouseData["Building classification"] || "Warehouse";
                    let yearBuilt = warehouseData["Year built/approved"];
                    let acres = warehouseData.Acres || 0;
                    
                    if (geoJsonFeature && geoJsonFeature.properties) {
                        buildingClass = geoJsonFeature.properties.class || buildingClass;
                        yearBuilt = geoJsonFeature.properties.year_built || yearBuilt;
                        if (geoJsonFeature.properties.shape_area) {
                            const calculatedAcres = (geoJsonFeature.properties.shape_area / 43560).toFixed(1);
                            acres = acres || calculatedAcres;
                        }
                    }
                    
                    const sqftProportion = ((sqft / totalSqft) * 100).toFixed(1);
                    
                    const warehouseNode = {
                        name: warehouseId,
                        color: "#8B4513",
                        details: `${buildingClass} - ${acres} acres, ${sqft.toLocaleString()} sq.ft. (${yearBuilt}) - ${sqftProportion}% of total`,
                        type: "warehouse",
                        data: warehouseData,
                        geoJsonFeature: geoJsonFeature,
                        sqft: sqft,
                        sqftProportion: parseFloat(sqftProportion),
                        children: []
                    };

                    // Add developer branch with pollution calculation based on sqft
                    if (developer) {
                        const devOrigin = cleanLocation(warehouseData.DevOriginCity);
                        if (devOrigin) {
                            const pollutionExport = calculatePollutionExport('developer', sqft, totalSqft, warehouseData);
                            
                            warehouseNode.children.push({
                                name: "Developer",
                                color: "#2E86C1",
                                details: developer,
                                type: "relationship",
                                children: [
                                    {
                                        name: developer,
                                        color: "#2E86C1",
                                        details: `Profits to: ${devOrigin}`,
                                        type: "entity",
                                        subtype: "developer",
                                        origin: devOrigin,
                                        pollutionExport: pollutionExport,
                                        warehouseSqft: sqft
                                    }
                                ]
                            });
                        }
                    }

                    // Add purchaser branch with pollution calculation based on sqft
                    if (purchaser) {
                        const purchOrigin = cleanLocation(warehouseData.PurchaserOriginCity);
                        const transactionType = warehouseData["Transaction Type"];
                        const validTransactionTypes = ['Purchase', 'Merger', 'Acquisition', 'Joint Venture'];
                        const cleanTransactionType = validTransactionTypes.includes(transactionType) ? transactionType : "Purchase";
                        
                        if (purchOrigin) {
                            const pollutionExport = calculatePollutionExport('purchaser', sqft, totalSqft, warehouseData);
                            
                            warehouseNode.children.push({
                                name: "Purchaser/Owner",
                                color: "#f39c12",
                                details: `${cleanTransactionType}: ${purchaser}`,
                                type: "relationship",
                                children: [
                                    {
                                        name: purchaser,
                                        color: "#f39c12",
                                        details: `Profits to: ${purchOrigin}`,
                                        type: "entity",
                                        subtype: "purchaser",
                                        origin: purchOrigin,
                                        pollutionExport: pollutionExport,
                                        warehouseSqft: sqft
                                    }
                                ]
                            });
                        }
                    }

                    // Add leasee branch with pollution calculation based on sqft
                    if (leasee) {
                        const leaseeOrigin = cleanLocation(warehouseData.LeaseeOriginCity);
                        if (leaseeOrigin) {
                            const pollutionExport = calculatePollutionExport('leasee', sqft, totalSqft, warehouseData);
                            
                            warehouseNode.children.push({
                                name: "Tenant",
                                color: "#27AE60",
                                details: `Operations: ${leasee}`,
                                type: "relationship",
                                children: [
                                    {
                                        name: leasee,
                                        color: "#27AE60",
                                        details: `Based in: ${leaseeOrigin}`,
                                        type: "entity",
                                        subtype: "leasee",
                                        origin: leaseeOrigin,
                                        pollutionExport: pollutionExport,
                                        warehouseSqft: sqft
                                    }
                                ]
                            });
                        }
                    }

                    mindMapData.children.push(warehouseNode);
                });

                return mindMapData;
            }

            // Convert mind map structure to nodes and edges for visualization
            async function convertMindMapToNetwork(mindMapData, geoJsonByApn) {
                const nodes = {};
                const edges = [];
                const nodeQueue = [{node: mindMapData, parent: null, level: 0}];
                const bloomingtonCoords = [-117.396, 34.070];
                
                while (nodeQueue.length > 0) {
                    const {node, parent, level} = nodeQueue.shift();
                    let nodeId = node.name;
                    
                    if (nodes[nodeId]) {
                        nodeId = `${node.name}_${Object.keys(nodes).filter(k => k.startsWith(node.name)).length}`;
                    }
                    
                    let coords;
                    if (node.type === "root") {
                        coords = await geocodeLocation(node.name);
                    } else if (node.type === "warehouse") {
                        const warehouseIndex = mindMapData.children.indexOf(node);
                        const apn = node.name;
                        coords = getWarehousePositionFromGeoJson(apn, geoJsonByApn, warehouseIndex, mindMapData.children.length);
                    } else if (node.type === "entity" && node.origin) {
                        coords = await getCoordinatesForEntity(node.origin, node.name);
                        if (!coords) {
                            console.warn(`Skipping entity node ${node.name} - no valid coordinates for ${node.origin}`);
                            continue;
                        }
                        
                        const distance = calculateDistance(coords, bloomingtonCoords);
                        node.pollutionExport = node.pollutionExport;
                        node.distanceFromBloomington = distance.toFixed(1);
                    } else {
                        const parentCoords = parent ? nodes[parent].coords : [0, 0];
                        const offset = 0.05 * (level - 1);
                        const angle = Math.random() * 2 * Math.PI;
                        coords = [
                            parentCoords[0] + offset * Math.cos(angle),
                            parentCoords[1] + offset * Math.sin(angle)
                        ];
                    }
                    
                    nodes[nodeId] = {
                        id: nodeId,
                        name: node.name,
                        type: node.type,
                        subtype: node.subtype,
                        color: node.color,
                        details: node.details,
                        coords: coords,
                        level: level,
                        data: node.data,
                        geoJsonFeature: node.geoJsonFeature,
                        connections: 0,
                        pollutionExport: node.pollutionExport,
                        distanceFromBloomington: node.distanceFromBloomington,
                        origin: node.origin
                    };
                    
                    if (parent) {
                        edges.push({
                            from: parent,
                            to: nodeId,
                            type: node.type === "relationship" ? "contains" : node.subtype || "relationship",
                            color: node.color,
                            level: level
                        });
                    }
                    
                    if (node.children) {
                        node.children.forEach(child => {
                            nodeQueue.push({node: child, parent: nodeId, level: level + 1});
                        });
                    }
                }
                
                edges.forEach(edge => {
                    if (nodes[edge.from]) nodes[edge.from].connections++;
                    if (nodes[edge.to]) nodes[edge.to].connections++;
                });
                
                return {nodes, edges};
            }

            // Load and parse CSV data
            async function loadData() {
                try {
                    let csvText = fallbackCsvData;
                    let geoJsonData = null;
                    
                    try {
                        console.log("Loading CSV from GitHub...");
                        const csvResponse = await fetch(csvUrl);
                        if (csvResponse.ok) {
                            csvText = await csvResponse.text();
                            console.log("Successfully loaded CSV from GitHub");
                        } else {
                            console.warn("Failed to load CSV from GitHub, using fallback data");
                        }
                    } catch (error) {
                        console.warn("Error loading CSV from GitHub:", error);
                    }
                    
                    try {
                        console.log("Loading GeoJSON from GitHub...");
                        const geoJsonResponse = await fetch(geoJsonUrl);
                        if (geoJsonResponse.ok) {
                            geoJsonData = await geoJsonResponse.json();
                            console.log("Successfully loaded GeoJSON from GitHub, features:", geoJsonData.features.length);
                        } else {
                            console.warn("Failed to load GeoJSON from GitHub");
                        }
                    } catch (error) {
                        console.warn("Error loading GeoJSON from GitHub:", error);
                    }
                    
                    const geoJsonByApn = {};
                    if (geoJsonData && geoJsonData.features) {
                        geoJsonData.features.forEach(feature => {
                            if (feature.properties && feature.properties.apn) {
                                const normalizedApn = normalizeAPN(feature.properties.apn);
                                geoJsonByApn[normalizedApn] = feature;
                                geoJsonByApn[feature.properties.apn] = feature;
                            }
                        });
                        console.log("Indexed GeoJSON features by APN:", Object.keys(geoJsonByApn));
                    }
                    
                    const lines = csvText.split('\n');
                    const fixedHeader = "Category,Assessor parcel number,Building classification,Year built/approved,Acres,Building sq.ft.,Developer,DevOriginCity,Purchaser/Merger,Transaction Type,Leasee,PurchaserOriginCity,LeaseeOriginCity,Endpoint";
                    lines[0] = fixedHeader;
                    const fixedCsv = lines.join('\n');
                    
                    const parsed = Papa.parse(fixedCsv, {
                        header: true,
                        dynamicTyping: function (header) {
                            if (header === "Assessor parcel number") {
                                return false;
                            }
                            return true;
                        },
                        skipEmptyLines: true
                    });

                    const mindMapData = buildMindMapData(parsed.data, geoJsonByApn);
                    const {nodes, edges} = await convertMindMapToNetwork(mindMapData, geoJsonByApn);
                    
                    const warehouses = Object.values(nodes).filter(n => n.type === 'warehouse');
                    const externalEntities = Object.values(nodes).filter(n => n.type === 'entity' && n.pollutionExport);
                    
                    // Calculate total pollution export from all external entities - should equal actual data
                    let totalPollutionExport = {
                        truckTrips: 0,
                        dieselPM: 0,
                        nox: 0,
                        co2: 0
                    };
                    
                    externalEntities.forEach(entity => {
                        if (entity.pollutionExport) {
                            totalPollutionExport.truckTrips += parseInt(entity.pollutionExport.truckTrips) || 0;
                            totalPollutionExport.dieselPM += parseFloat(entity.pollutionExport.dieselPM) || 0;
                            totalPollutionExport.nox += parseInt(entity.pollutionExport.nox) || 0;
                            totalPollutionExport.co2 += parseFloat(entity.pollutionExport.co2) || 0;
                        }
                    });
                    
                    // Verify totals match original pollution data (within rounding)
                    console.log("Pollution distribution verification:");
                    console.log(`Truck trips: ${totalPollutionExport.truckTrips} / ${pollutionData.dailyTruckTrips} (${((totalPollutionExport.truckTrips/pollutionData.dailyTruckTrips)*100).toFixed(1)}%)`);
                    console.log(`Diesel PM: ${totalPollutionExport.dieselPM.toFixed(2)} / ${pollutionData.dailyDieselPM} (${((totalPollutionExport.dieselPM/pollutionData.dailyDieselPM)*100).toFixed(1)}%)`);
                    console.log(`NOx: ${totalPollutionExport.nox} / ${pollutionData.dailyNOx} (${((totalPollutionExport.nox/pollutionData.dailyNOx)*100).toFixed(1)}%)`);
                    console.log(`CO2: ${totalPollutionExport.co2.toFixed(1)} / ${pollutionData.dailyCO2} (${((totalPollutionExport.co2/pollutionData.dailyCO2)*100).toFixed(1)}%)`);
                    
                    const stats = {
                        totalWarehouses: warehouses.length,
                        totalAcres: warehouses.reduce((sum, w) => sum + (w.data?.Acres || 0), 0),
                        totalSqft: warehouses.reduce((sum, w) => sum + (w.data?.["Building sq.ft."] || w.sqft || 0), 0),
                        developers: Object.values(nodes).filter(n => n.subtype === 'developer').length,
                        purchasers: Object.values(nodes).filter(n => n.subtype === 'purchaser').length,
                        leasees: Object.values(nodes).filter(n => n.subtype === 'leasee').length,
                        geoJsonFeatures: Object.keys(geoJsonByApn).length,
                        externalEntities: externalEntities.length,
                        totalPollutionExport: totalPollutionExport,
                        actualPollutionData: pollutionData
                    };

                    console.log("Data processing complete. Pollution export calculated for", externalEntities.length, "external entities");
                    return { nodes, edges, mindMapData, stats, geoJsonByApn };
                } catch (error) {
                    console.error("Error loading data:", error);
                    throw error;
                }
            }

            // Initialize map and create network
            async function initializeMap() {
                try {
                    const map = new Map({
                        basemap: "gray-vector"
                    });

                    const view = new MapView({
                        container: "viewDiv",
                        map: map,
                        center: [-117.396, 34.070],
                        zoom: 11
                    });
                    
                    networkView = view;

                    const warehouseLayer = new GraphicsLayer({ title: "Warehouse Footprints" });
                    edgeLayer = new GraphicsLayer({ title: "Pollution Flows" });
                    nodeLayer = new GraphicsLayer({ title: "Entities" });
                    labelLayer = new GraphicsLayer({ title: "Labels" });
                    pollutionLayer = new GraphicsLayer({ title: "Pollution Visualization" });
                    
                    map.addMany([warehouseLayer, edgeLayer, nodeLayer, labelLayer, pollutionLayer]);

                    await view.when();

                    const { nodes, edges, mindMapData, stats, geoJsonByApn } = await loadData();
                    
                    allNodes = nodes;
                    allEdges = edges;
                    
                    // Update statistics panel with pollution data
                    document.getElementById("statsSection").innerHTML = `
                        <div><strong>${stats.totalWarehouses}</strong> Warehouse Properties</div>
                        <div><strong>${stats.totalAcres.toLocaleString()}</strong> Total Acres</div>
                        <div><strong>${(stats.totalSqft / 1000000).toFixed(1)}M</strong> Total Sq.Ft.</div>
                        <div style="margin-top: 8px;">
                            <strong>${stats.developers}</strong> Developers • 
                            <strong>${stats.purchasers}</strong> Owners • 
                            <strong>${stats.leasees}</strong> Tenants
                        </div>
                        <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #ddd;">
                            <div style="font-size: 12px; color: #e74c3c; font-weight: bold;">External Pollution Export:</div>
                            <div style="font-size: 11px; margin: 2px 0;">
                                <strong>${stats.totalPollutionExport.truckTrips.toLocaleString()}</strong> truck trips/day
                            </div>
                            <div style="font-size: 11px; margin: 2px 0;">
                                <strong>${stats.totalPollutionExport.dieselPM.toFixed(1)} lbs</strong> Diesel PM/day
                            </div>
                            <div style="font-size: 11px; margin: 2px 0;">
                                <strong>${stats.totalPollutionExport.nox.toLocaleString()} lbs</strong> NOx/day
                            </div>
                            <div style="font-size: 11px; margin: 2px 0;">
                                <strong>${stats.totalPollutionExport.co2.toFixed(1)} tons</strong> CO2/day
                            </div>
                        </div>
                        <div style="margin-top: 5px; font-size: 10px; color: #666;">
                            ${stats.externalEntities} external entities • ${stats.geoJsonFeatures} footprints
                        </div>
                    `;
                    
                    // Add warehouse footprints
                    console.log("Adding warehouse footprints...");
                    let footprintCount = 0;
                    Object.entries(geoJsonByApn).forEach(([apn, feature]) => {
                        if (feature.geometry && (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon')) {
                            try {
                                let rings;
                                if (feature.geometry.type === 'MultiPolygon') {
                                    rings = [];
                                    feature.geometry.coordinates.forEach(polygon => {
                                        rings.push(...polygon);
                                    });
                                } else {
                                    rings = feature.geometry.coordinates;
                                }
                                
                                const polygon = new Polygon({
                                    rings: rings,
                                    spatialReference: { wkid: 4326 }
                                });
                                
                                const fillSymbol = new SimpleFillSymbol({
                                    color: [139, 69, 19, 0.3],
                                    outline: {
                                        color: [139, 69, 19],
                                        width: 2
                                    }
                                });
                                
                                const polygonGraphic = new Graphic({
                                    geometry: polygon,
                                    symbol: fillSymbol,
                                    attributes: {
                                        apn: apn,
                                        warehouseData: feature.properties,
                                        type: 'warehousePolygon'
                                    }
                                });
                                
                                warehouseLayer.add(polygonGraphic);
                                footprintCount++;
                            } catch (error) {
                                console.error(`Error adding polygon for APN ${apn}:`, error);
                            }
                        }
                    });
                    console.log(`Added ${footprintCount} warehouse footprints`);
                    
                    updateNetworkVisualization();
                    
                    document.getElementById("loadingDiv").style.display = "none";
                    document.getElementById("infoPanel").style.display = "block";
                    
                    // Update extent to show all graphics
                    if (nodeLayer.graphics.length > 0) {
                        view.goTo(nodeLayer.graphics.concat(edgeLayer.graphics).concat(warehouseLayer.graphics), {
                            padding: { top: 50, bottom: 50, left: 50, right: 420 }
                        });
                    }
                    
                    // Handle click events
                    view.on("click", function(event) {
                        view.hitTest(event).then(function(response) {
                            const graphic = response.results[0]?.graphic;
                            if (graphic && graphic.attributes) {
                                const attrs = graphic.attributes;
                                
                                if (attrs.nodeId && (attrs.type === 'warehouse' || attrs.type === 'root' || 
                                    (attrs.type === 'entity' && hasChildNodes(attrs.nodeId)))) {
                                    
                                    if (event.native.shiftKey) {
                                        displayNodeInfo(attrs, mindMapData);
                                    } else {
                                        const childCount = countDirectChildren(attrs.nodeId);
                                        if (childCount > 0) {
                                            window.toggleNodeExpansion(attrs.nodeId);
                                        } else {
                                            displayNodeInfo(attrs, mindMapData);
                                        }
                                    }
                                } else {
                                    displayNodeInfo(attrs, mindMapData);
                                }
                            }
                        });
                    });
                    
                    // Function to display node information with pollution data
                    function displayNodeInfo(attrs, mindMapData) {
                        let infoHtml = "";
                        let currentNodeId = attrs.nodeId || attrs.id || attrs.name;
                        const bloomingtonCoords = [-117.396, 34.070];
                        
                        if (attrs.type === "root") {
                            infoHtml = `<h4>🚨 ${attrs.name}</h4>`;
                            infoHtml += `<div class="pollution-stats">`;
                            infoHtml += `<div style="font-weight: bold; color: #e74c3c;">POLLUTION CONCENTRATION ZONE</div>`;
                            infoHtml += `<div style="margin-top: 5px;">Environmental burden from ${mindMapData.children.length} warehouse operations</div>`;
                            infoHtml += `<div style="margin-top: 8px; font-size: 11px;">`;
                            infoHtml += `<div><strong>Daily Impact:</strong></div>`;
                            infoHtml += `<div>• ${pollutionData.dailyTruckTrips.toLocaleString()} truck trips</div>`;
                            infoHtml += `<div>• ${pollutionData.dailyDieselPM} lbs Diesel PM</div>`;
                            infoHtml += `<div>• ${pollutionData.dailyNOx} lbs NOx</div>`;
                            infoHtml += `<div>• ${pollutionData.dailyCO2} metric tons CO2</div>`;
                            infoHtml += `</div></div>`;
                            currentNodeId = attrs.id || "Bloomington, CA";
                            
                        } else if (attrs.type === "warehouse") {
                            const warehouseData = attrs.data;
                            infoHtml = `<h4>📦 Warehouse: ${attrs.id}</h4>`;
                            infoHtml += `<div class="warehouse-details">`;
                            infoHtml += `<div>${attrs.details}</div>`;
                            
                            if (attrs.geoJsonFeature && attrs.geoJsonFeature.properties) {
                                const props = attrs.geoJsonFeature.properties;
                                if (props.shape_area) {
                                    infoHtml += `<div><strong>Area:</strong> ${(props.shape_area / 43560).toFixed(1)} acres (${props.shape_area.toLocaleString()} sq.ft.)</div>`;
                                }
                            }
                            
                            if (warehouseData?.Category) {
                                infoHtml += `<div><strong>Status:</strong> ${warehouseData.Category}</div>`;
                            }
                            if (warehouseData?.["Year built/approved"]) {
                                infoHtml += `<div><strong>Year:</strong> ${warehouseData["Year built/approved"]}</div>`;
                            }
                            infoHtml += `</div>`;
                            
                            currentNodeId = attrs.nodeId || attrs.id || attrs.name;
                            
                            const warehouseBranch = mindMapData.children.find(w => 
                                w.name === attrs.id || w.name === attrs.name
                            );
                            
                            if (warehouseBranch && warehouseBranch.children.length > 0) {
                                infoHtml += `<h5>🏢 Ownership & Pollution Export:</h5>`;
                                warehouseBranch.children.forEach(branch => {
                                    infoHtml += `<div class="mind-map-branch" style="border-left-color: ${branch.color};">`;
                                    infoHtml += `<div class="branch-title">${branch.name}</div>`;
                                    infoHtml += `<div class="branch-details">${branch.details}</div>`;
                                    if (branch.children && branch.children.length > 0) {
                                        infoHtml += `<div class="tree-structure">`;
                                        branch.children.forEach(entity => {
                                            infoHtml += `<div class="tree-node">`;
                                            infoHtml += `<strong>${entity.name}</strong><br>`;
                                            infoHtml += `<span style="font-size: 11px;">${entity.details}</span>`;
                                            
                                            // Add pollution export info if available
                                            const entityNode = Object.values(allNodes).find(n => 
                                                n.name === entity.name && n.type === 'entity'
                                            );
                                            if (entityNode && entityNode.pollutionExport) {
                                                infoHtml += `<div class="pollution-export">`;
                                                infoHtml += `<div style="font-weight: bold; color: #e74c3c;">Pollution Export to Bloomington:</div>`;
                                                infoHtml += `<div style="font-size: 10px; margin-top: 3px;">`;
                                                infoHtml += `• ${entityNode.pollutionExport.truckTrips} truck trips/day<br>`;
                                                infoHtml += `• ${entityNode.pollutionExport.dieselPM} lbs Diesel PM/day<br>`;
                                                infoHtml += `• ${entityNode.pollutionExport.nox} lbs NOx/day<br>`;
                                                infoHtml += `• ${entityNode.pollutionExport.co2} tons CO2/day<br>`;
                                                infoHtml += `• Warehouse size: ${entityNode.pollutionExport.warehouseSqft} sq.ft.<br>`;
                                                infoHtml += `• Share of total: ${entityNode.pollutionExport.sqftProportion}%`;
                                                infoHtml += `</div></div>`;
                                            }
                                            infoHtml += `</div>`;
                                        });
                                        infoHtml += `</div>`;
                                    }
                                    infoHtml += `</div>`;
                                });
                            }
                            
                        } else if (attrs.warehouseData || attrs.type === 'warehousePolygon') {
                            const props = attrs.warehouseData;
                            infoHtml = `<h4>📦 Warehouse: ${props.apn}</h4>`;
                            infoHtml += `<div class="warehouse-details">`;
                            infoHtml += `<div><strong>Classification:</strong> ${props.class || props.building_classification || 'N/A'}</div>`;
                            infoHtml += `<div><strong>Year Built:</strong> ${props.year_built || 'N/A'}</div>`;
                            infoHtml += `<div><strong>Category:</strong> ${props.category || 'N/A'}</div>`;
                            if (props.shape_area) {
                                infoHtml += `<div><strong>Area:</strong> ${(props.shape_area / 43560).toFixed(1)} acres (${props.shape_area.toLocaleString()} sq.ft.)</div>`;
                            }
                            infoHtml += `</div>`;
                            
                            const warehouseNode = Object.values(allNodes).find(n => {
                                if (n.type !== 'warehouse') return false;
                                const nodeApn = normalizeAPN(n.name);
                                const propsApn = normalizeAPN(props.apn);
                                return nodeApn === propsApn || n.name === props.apn || n.id === props.apn;
                            });
                            
                            if (warehouseNode && warehouseNode.data) {
                                const warehouseData = warehouseNode.data;
                                infoHtml += `<h5>🏢 Ownership Information:</h5>`;
                                
                                if (warehouseData.Developer) {
                                    infoHtml += `<div class="branch-details"><strong>Developer:</strong> ${warehouseData.Developer}</div>`;
                                }
                                if (warehouseData["Purchaser/Merger"]) {
                                    infoHtml += `<div class="branch-details"><strong>Owner:</strong> ${warehouseData["Purchaser/Merger"]}</div>`;
                                }
                                if (warehouseData.Leasee) {
                                    infoHtml += `<div class="branch-details"><strong>Tenant:</strong> ${warehouseData.Leasee}</div>`;
                                }
                            }
                            
                        } else if (attrs.type === "relationship") {
                            infoHtml = `<h4>${attrs.name}</h4>`;
                            infoHtml += `<p>${attrs.details}</p>`;
                            currentNodeId = attrs.nodeId || attrs.id || attrs.name;
                            
                        } else if (attrs.type === "entity") {
                            const entityTypeEmoji = {
                                'developer': '🏗️',
                                'purchaser': '💰',
                                'leasee': '🚛'
                            };
                            
                            infoHtml = `<h4>${entityTypeEmoji[attrs.subtype] || '🏢'} ${attrs.name}</h4>`;
                            infoHtml += `<p><strong>Type:</strong> ${attrs.subtype.charAt(0).toUpperCase() + attrs.subtype.slice(1)}</p>`;
                            infoHtml += `<p>${attrs.details}</p>`;
                            
                            // Add pollution export information
                            if (attrs.pollutionExport) {
                                infoHtml += `<div class="pollution-export">`;
                                infoHtml += `<div style="font-weight: bold; color: #e74c3c; margin-bottom: 8px;">🚨 Pollution Export to Bloomington:</div>`;
                                infoHtml += `<div style="font-size: 12px;">`;
                                infoHtml += `<div><strong>${attrs.pollutionExport.truckTrips}</strong> truck trips/day</div>`;
                                infoHtml += `<div><strong>${attrs.pollutionExport.dieselPM}</strong> lbs Diesel PM/day</div>`;
                                infoHtml += `<div><strong>${attrs.pollutionExport.nox}</strong> lbs NOx/day</div>`;
                                infoHtml += `<div><strong>${attrs.pollutionExport.co2}</strong> metric tons CO2/day</div>`;
                                infoHtml += `<div style="margin-top: 5px; font-size: 11px; color: #666;">`;
                                infoHtml += `Warehouse size: ${attrs.pollutionExport.warehouseSqft} sq.ft.<br>`;
                                infoHtml += `Share of total operations: ${attrs.pollutionExport.sqftProportion}%<br>`;
                                infoHtml += `Distance: ${attrs.distanceFromBloomington} miles from Bloomington`;
                                infoHtml += `</div>`;
                                infoHtml += `</div></div>`;
                                
                                // Add environmental justice note
                                if (attrs.origin) {
                                    const avgIncomeNote = getIncomeNote(attrs.origin);
                                    if (avgIncomeNote) {
                                        infoHtml += `<div style="background: #fff3e0; padding: 8px; margin: 8px 0; border-radius: 4px; font-size: 11px;">`;
                                        infoHtml += `<strong>Environmental Justice Impact:</strong><br>`;
                                        infoHtml += `${avgIncomeNote}`;
                                        infoHtml += `</div>`;
                                    }
                                }
                            }
                            
                            if (attrs.connections > 0) {
                                infoHtml += `<p><strong>Connections:</strong> ${attrs.connections}</p>`;
                            }
                            currentNodeId = attrs.nodeId || attrs.id || attrs.name;
                            
                        } else if (attrs.from && attrs.to) {
                            infoHtml = `<h4>🔗 Connection</h4>`;
                            infoHtml += `<p><strong>From:</strong> ${attrs.from}</p>`;
                            infoHtml += `<p><strong>To:</strong> ${attrs.to}</p>`;
                            infoHtml += `<p><strong>Type:</strong> ${attrs.type}</p>`;
                            
                            // Add pollution flow information if available
                            if (attrs.pollutionExport) {
                                infoHtml += `<div class="pollution-export">`;
                                infoHtml += `<div style="font-weight: bold; color: #e74c3c;">Pollution Flow:</div>`;
                                infoHtml += `<div style="font-size: 12px; margin-top: 5px;">`;
                                infoHtml += `${attrs.pollutionExport.truckTrips} trucks/day<br>`;
                                infoHtml += `${attrs.pollutionExport.dieselPM} lbs Diesel PM/day<br>`;
                                infoHtml += `${attrs.pollutionExport.nox} lbs NOx/day<br>`;
                                infoHtml += `${attrs.pollutionExport.co2} tons CO2/day<br>`;
                                infoHtml += `Distance: ${attrs.distance} miles`;
                                infoHtml += `</div></div>`;
                            }
                        }
                        
                        document.getElementById("nodeInfo").innerHTML = infoHtml || "<p>Click on nodes for details</p>";
                        
                        // Add instruction about clicking nodes
                        if (currentNodeId && (attrs.type === 'warehouse' || attrs.type === 'root' || 
                            (attrs.type === 'entity' && hasChildNodes(currentNodeId)))) {
                            const childCount = countDirectChildren(currentNodeId);
                            if (childCount > 0) {
                                const isCollapsed = collapsedNodes.has(currentNodeId);
                                const instruction = `<p style="font-size: 12px; color: #666; margin-top: 10px;">
                                    <em>Click node to ${isCollapsed ? 'expand' : 'collapse'} • Shift+Click for info only</em>
                                </p>`;
                                document.getElementById("nodeInfo").innerHTML += instruction;
                            }
                        }
                    }
                    
                    // Helper function to get income disparity notes
                    function getIncomeNote(location) {
                        const wealthyAreas = {
                            "Newport Beach, CA": "Profits flow to Newport Beach (median income ~$120k) while pollution stays in Bloomington (median income ~$35k)",
                            "Highland Park, TX": "Profits flow to Highland Park (median income ~$140k) while pollution stays in Bloomington (median income ~$35k)",
                            "Bethesda, MD": "Profits flow to Bethesda (median income ~$130k) while pollution stays in Bloomington (median income ~$35k)",
                            "Pacific Heights, CA": "Profits flow to Pacific Heights (median income ~$150k+) while pollution stays in Bloomington (median income ~$35k)",
                            "Lemon Heights, CA": "Profits flow to Lemon Heights (median income ~$100k) while pollution stays in Bloomington (median income ~$35k)",
                            "Evergreen, CO": "Profits flow to Evergreen (median income ~$90k) while pollution stays in Bloomington (median income ~$35k)"
                        };
                        return wealthyAreas[location];
                    }
                    
                    // Add keyboard shortcuts
                    view.on("key-down", function(event) {
                        if (event.key === "r" || event.key === "R") {
                            view.goTo(nodeLayer.graphics.concat(edgeLayer.graphics).concat(warehouseLayer.graphics), {
                                padding: { top: 50, bottom: 50, left: 50, right: 420 }
                            });
                        } else if (event.key === "c" || event.key === "C") {
                            view.goTo({
                                center: cityCoords["Bloomington, CA"],
                                zoom: 11
                            });
                        } else if (event.key === "p" || event.key === "P") {
                            togglePollutionView();
                        }
                    });
                    
                } catch (error) {
                    console.error("Failed to initialize map:", error);
                    document.getElementById("loadingDiv").style.display = "none";
                    document.getElementById("errorDiv").style.display = "block";
                    document.getElementById("errorMessage").textContent = error.message;
                }
            }

            // Start the application
            initializeMap();
        });
    </script>
</body>
</html>
