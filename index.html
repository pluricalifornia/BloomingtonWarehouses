<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>Bloomington Warehouse Ownership Network Map</title>
    
    <link rel="stylesheet" href="https://js.arcgis.com/4.27/esri/themes/light/main.css">
    <style>
        html, body, #viewDiv {
            padding: 0;
            margin: 0;
            height: 100%;
            width: 100%;
        }
        
        #infoPanel {
            position: absolute;
            top: 15px;
            right: 15px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            max-width: 380px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 99;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        
        .legend-line {
            width: 30px;
            height: 3px;
            margin-right: 10px;
        }
        
        .legend-circle {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
            border: 2px solid white;
            box-shadow: 0 0 2px rgba(0,0,0,0.3);
        }
        
        .node-info {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #ddd;
        }
        
        .warehouse-details {
            background: #f5f5f5;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 13px;
        }
        
        .mind-map-branch {
            margin: 10px 0;
            padding: 10px;
            background: #f9f9f9;
            border-left: 4px solid #3498db;
            border-radius: 4px;
        }
        
        .branch-title {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .branch-details {
            font-size: 12px;
            color: #555;
            margin: 5px 0;
        }
        
        #loadingDiv {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        
        #errorDiv {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            display: none;
            max-width: 400px;
        }
        
        .stats-section {
            background: #e8f4f8;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-size: 13px;
        }
        
        .warehouse-node-legend {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #ddd;
        }
        
        .tree-structure {
            margin-left: 15px;
            border-left: 2px solid #ddd;
            padding-left: 10px;
        }
        
        .tree-node {
            margin: 5px 0;
            position: relative;
        }
        
        .tree-node::before {
            content: "";
            position: absolute;
            left: -12px;
            top: 10px;
            width: 10px;
            height: 1px;
            background: #ddd;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://js.arcgis.com/4.27/"></script>
</head>
<body>
    <div id="viewDiv"></div>
    <div id="loadingDiv">
        <h3>Loading Network Map...</h3>
        <p>Processing warehouse ownership data</p>
    </div>
    <div id="errorDiv">
        <h3>Error Loading Data</h3>
        <p id="errorMessage"></p>
    </div>
    <div id="infoPanel" style="display: none;">
        <h3>Warehouse Ownership Network</h3>
        <p><strong>Bloomington, CA</strong></p>
        
        <div class="stats-section" id="statsSection">
            <!-- Stats will be populated dynamically -->
        </div>
        
        <div class="legend">
            <h4>Entity Types</h4>
            <div class="legend-item">
                <div class="legend-circle" style="background: #34495e;"></div>
                <span>Central Hub (Bloomington)</span>
            </div>
            <div class="legend-item">
                <div class="legend-circle" style="background: #8B4513;"></div>
                <span>Warehouse Property</span>
            </div>
            <div class="legend-item">
                <div class="legend-circle" style="background: #2E86C1;"></div>
                <span>Developer</span>
            </div>
            <div class="legend-item">
                <div class="legend-circle" style="background: #E74C3C;"></div>
                <span>Purchaser/Owner</span>
            </div>
            <div class="legend-item">
                <div class="legend-circle" style="background: #F39C12;"></div>
                <span>Leasee/Tenant</span>
            </div>
            <div class="legend-item">
                <div class="legend-circle" style="background: #3498DB;"></div>
                <span>City/Headquarters</span>
            </div>
        </div>
        
        <div class="warehouse-node-legend">
            <h4>Connection Types</h4>
            <div class="legend-item">
                <div class="legend-line" style="background: #8B4513; width: 4px;"></div>
                <span>Contains Warehouse</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #2E86C1; width: 4px;"></div>
                <span>Developed by</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #E74C3C; width: 4px;"></div>
                <span>Purchased/Merged</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #F39C12; width: 3px;"></div>
                <span>Leased to</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #27AE60; width: 2px; border-style: dashed;"></div>
                <span>Headquartered in</span>
            </div>
        </div>
        
        <div class="node-info" id="nodeInfo">
            <p>Click on nodes for details</p>
        </div>
    </div>

    <script>
        // GitHub repository URLs
        const githubBaseUrl = "https://raw.githubusercontent.com/pluricalifornia/BloomingtonWarehouses/main/";
        const csvUrl = githubBaseUrl + "data/WarehouseTracker.csv";
        const geoJsonUrl = githubBaseUrl + "data/warehouses%20(1).geojson";
        
        // Fallback embedded data for testing
        const fallbackCsvData = `"Category","Assessor parcel number","Building classification","Year built/approved","Acres","Building sq.ft.",Developer,DevOriginCity,Purchaser/Merger,Category,Leasee,PurchaserOriginCity,LeaseeOriginCity,Endpoint
"Approved","Bloomington Business Park","https://ceqanet.opr.ca.gov/2020120545/3","2025","181","4340000",Howard Industrial Partners LLC,"Lemon Heights, CA",TBD,TBD,TBD,TBD,TBD,"Bloomington, CA"
"Existing","025217367","transit warehouse (truck terminal)","2001","47","1133000",Pacific Industrial,"Newport Beach, CA",Realterm,Purchase,YellowCorp,"Annapolis, MD",TBD,"Bloomington, CA"
"Existing","Bloomington Logistics Center","distribution warehouse","2019","35","827000", Crow holdings Industrial, "Highland Park, TX", ASB Real Estate Investments,Purchase,TBD,"Bethseda, MD",TBD,"Bloomington, CA"
"Existing","025215217","distribution warehouse","2018","28","674000", DCT Industrial Trust,"Evergreen, CO",Prologis,Merger,TBD,"Pacific Heights, CA",TBD,"Bloomington, CA"`;

        require([
            "esri/Map",
            "esri/views/MapView",
            "esri/Graphic",
            "esri/layers/GraphicsLayer",
            "esri/geometry/Point",
            "esri/geometry/Polygon",
            "esri/geometry/Polyline",
            "esri/symbols/SimpleMarkerSymbol",
            "esri/symbols/SimpleFillSymbol",
            "esri/symbols/SimpleLineSymbol",
            "esri/symbols/TextSymbol",
            "esri/rest/locator",
            "esri/widgets/Popup"
        ], function(Map, MapView, Graphic, GraphicsLayer, Point, Polygon, Polyline, 
                   SimpleMarkerSymbol, SimpleFillSymbol, SimpleLineSymbol, TextSymbol, locator, Popup) {

            // Cache for geocoded locations
            const geocodeCache = {};
            
            // Predefined coordinates for known cities
            const cityCoords = {
                "Bloomington, CA": [-117.396, 34.070],
                "Lemon Heights, CA": [-117.823, 33.765],
                "Newport Beach, CA": [-117.928, 33.618],
                "Annapolis, MD": [-76.492, 38.978],
                "Highland Park, TX": [-96.792, 32.834],
                "Bethesda, MD": [-77.094, 38.984],
                "Bethseda, MD": [-77.094, 38.984], // Handle typo
                "Evergreen, CO": [-105.321, 39.633],
                "Pacific Heights, CA": [-122.447, 37.794],
                "San Francisco, CA": [-122.419, 37.774],
                "Denver, CO": [-104.990, 39.739],
                "Irvine, CA": [-117.826, 33.684],
                "Costa Mesa, CA": [-117.919, 33.641]
            };

            // Function to get centroid of a polygon
            function getPolygonCentroid(coordinates) {
                let sumX = 0, sumY = 0, count = 0;
                
                // Handle MultiPolygon
                if (coordinates.length > 0 && Array.isArray(coordinates[0][0][0])) {
                    // It's a MultiPolygon
                    coordinates.forEach(polygon => {
                        polygon.forEach(ring => {
                            ring.forEach(coord => {
                                sumX += coord[0];
                                sumY += coord[1];
                                count++;
                            });
                        });
                    });
                } else {
                    // It's a regular Polygon
                    coordinates.forEach(ring => {
                        ring.forEach(coord => {
                            sumX += coord[0];
                            sumY += coord[1];
                            count++;
                        });
                    });
                }
                
                return [sumX / count, sumY / count];
            }

            // Get warehouse position from GeoJSON or generate one
            function getWarehousePositionFromGeoJson(apn, geoJsonByApn, index, total) {
                const feature = geoJsonByApn[apn];
                if (feature && feature.geometry) {
                    return getPolygonCentroid(feature.geometry.coordinates);
                }
                
                // Fallback to generated position if no GeoJSON match
                const bloomingtonCoords = cityCoords["Bloomington, CA"];
                const radius = 0.15;
                const angle = (index / total) * 2 * Math.PI;
                
                return [
                    bloomingtonCoords[0] + radius * Math.cos(angle),
                    bloomingtonCoords[1] + radius * Math.sin(angle)
                ];
            }

            // Geocoding function
            async function geocodeLocation(address) {
                if (geocodeCache[address]) {
                    return geocodeCache[address];
                }
                
                if (cityCoords[address]) {
                    geocodeCache[address] = cityCoords[address];
                    return cityCoords[address];
                }
                
                try {
                    const geocodeUrl = "https://geocode-api.arcgis.com/arcgis/rest/services/World/GeocodeServer";
                    const result = await locator.addressToLocations(geocodeUrl, {
                        address: {
                            SingleLine: address
                        },
                        maxLocations: 1
                    });
                    
                    if (result && result.length > 0) {
                        const coords = [result[0].location.longitude, result[0].location.latitude];
                        geocodeCache[address] = coords;
                        return coords;
                    }
                } catch (error) {
                    console.warn(`Geocoding failed for ${address}:`, error);
                }
                
                const defaultCoords = [-117.4 + (Math.random() - 0.5) * 2, 34.0 + (Math.random() - 0.5) * 2];
                geocodeCache[address] = defaultCoords;
                return defaultCoords;
            }

            // Function to get coordinates with offset for multiple entities
            const entityOffsets = {};
            async function getCoordinatesForEntity(location, entityName) {
                const baseCoords = await geocodeLocation(location);
                
                const key = location + "|" + entityName;
                if (!entityOffsets[key]) {
                    const count = Object.keys(entityOffsets).filter(k => k.startsWith(location)).length;
                    const angle = (count * 72) * Math.PI / 180;
                    const offset = 0.05;
                    entityOffsets[key] = [
                        baseCoords[0] + offset * Math.cos(angle),
                        baseCoords[1] + offset * Math.sin(angle)
                    ];
                }
                return entityOffsets[key];
            }

            // Helper functions for data cleaning
            function cleanLocation(location) {
                if (!location || typeof location !== 'string') return null;
                
                let cleaned = location.trim().replace(/["\\"]/g, '').trim();
                
                const invalidLocations = ['TBD', 'TBA', 'N/A', 'CA', 'TX', 'Florida', 'Unknown', ''];
                if (invalidLocations.includes(cleaned)) return null;
                
                if (cleaned === 'Bethseda, MD') cleaned = 'Bethesda, MD';
                
                const cityStateMap = {
                    'Highland Park': 'Highland Park, TX',
                    'Miami Beach': 'Miami Beach, FL'
                };
                
                if (cityStateMap[cleaned]) {
                    cleaned = cityStateMap[cleaned];
                }
                
                return cleaned;
            }
            
            function cleanEntityName(name) {
                if (!name || typeof name !== 'string') return null;
                
                let cleaned = name.trim().replace(/["\\"]/g, '').trim();
                
                const invalidNames = ['TBD', 'TBA', 'N/A', 'Purchase', 'Merger', ''];
                if (invalidNames.includes(cleaned)) return null;
                
                return cleaned;
            }

            // Build mind map data structure
            function buildMindMapData(parsedData, geoJsonByApn) {
                const mindMapData = {
                    name: "Bloomington, CA",
                    color: "#34495e",
                    details: "Central hub for warehouse development in San Bernardino County",
                    type: "root",
                    children: []
                };

                parsedData.forEach((row, index) => {
                    const warehouseId = row["Assessor parcel number"] || `Warehouse_${index}`;
                    const developer = cleanEntityName(row.Developer);
                    const purchaser = cleanEntityName(row["Purchaser/Merger"]);
                    const leasee = cleanEntityName(row.Leasee);
                    
                    // Get additional data from GeoJSON if available
                    const geoJsonFeature = geoJsonByApn[warehouseId];
                    let buildingClass = row["Building classification"] || "Warehouse";
                    let yearBuilt = row["Year built/approved"];
                    let acres = row.Acres || 0;
                    let sqft = row["Building sq.ft."] || 0;
                    
                    if (geoJsonFeature && geoJsonFeature.properties) {
                        buildingClass = geoJsonFeature.properties.class || buildingClass;
                        yearBuilt = geoJsonFeature.properties.year_built || yearBuilt;
                        if (geoJsonFeature.properties.shape_area) {
                            // Convert shape_area to acres if needed (assuming it's in square feet)
                            const calculatedAcres = (geoJsonFeature.properties.shape_area / 43560).toFixed(1);
                            acres = acres || calculatedAcres;
                        }
                    }
                    
                    const warehouseNode = {
                        name: warehouseId,
                        color: "#8B4513",
                        details: `${buildingClass} - ${acres} acres, ${parseInt(sqft).toLocaleString()} sq.ft. (${yearBuilt})`,
                        type: "warehouse",
                        data: row,
                        geoJsonFeature: geoJsonFeature,
                        children: []
                    };

                    // Add developer branch
                    if (developer) {
                        const devOrigin = cleanLocation(row.DevOriginCity);
                        warehouseNode.children.push({
                            name: "Developer",
                            color: "#2E86C1",
                            details: developer,
                            type: "relationship",
                            children: [
                                {
                                    name: developer,
                                    color: "#2E86C1",
                                    details: `Headquarters: ${devOrigin || "Unknown"}`,
                                    type: "entity",
                                    subtype: "developer",
                                    origin: devOrigin
                                }
                            ]
                        });
                    }

                    // Add purchaser branch
                    if (purchaser) {
                        const purchOrigin = cleanLocation(row.PurchaserOriginCity);
                        warehouseNode.children.push({
                            name: "Purchaser/Owner",
                            color: "#E74C3C",
                            details: `${row["Transaction Type"] || "Purchase"}: ${purchaser}`,
                            type: "relationship",
                            children: [
                                {
                                    name: purchaser,
                                    color: "#E74C3C",
                                    details: `Headquarters: ${purchOrigin || "Unknown"}`,
                                    type: "entity",
                                    subtype: "purchaser",
                                    origin: purchOrigin
                                }
                            ]
                        });
                    }

                    // Add leasee branch
                    if (leasee) {
                        const leaseeOrigin = cleanLocation(row.LeaseeOriginCity);
                        warehouseNode.children.push({
                            name: "Tenant",
                            color: "#F39C12",
                            details: `Leased to: ${leasee}`,
                            type: "relationship",
                            children: [
                                {
                                    name: leasee,
                                    color: "#F39C12",
                                    details: `Headquarters: ${leaseeOrigin || "Unknown"}`,
                                    type: "entity",
                                    subtype: "leasee",
                                    origin: leaseeOrigin
                                }
                            ]
                        });
                    }

                    mindMapData.children.push(warehouseNode);
                });

                return mindMapData;
            }

            // Convert mind map structure to nodes and edges for visualization
            async function convertMindMapToNetwork(mindMapData, geoJsonByApn) {
                const nodes = {};
                const edges = [];
                const nodeQueue = [{node: mindMapData, parent: null, level: 0}];
                
                while (nodeQueue.length > 0) {
                    const {node, parent, level} = nodeQueue.shift();
                    let nodeId = node.name;
                    
                    if (nodes[nodeId]) {
                        nodeId = `${node.name}_${Object.keys(nodes).filter(k => k.startsWith(node.name)).length}`;
                    }
                    
                    let coords;
                    if (node.type === "root") {
                        coords = await geocodeLocation(node.name);
                    } else if (node.type === "warehouse") {
                        const warehouseIndex = mindMapData.children.indexOf(node);
                        const apn = node.name;
                        coords = getWarehousePositionFromGeoJson(apn, geoJsonByApn, warehouseIndex, mindMapData.children.length);
                    } else if (node.type === "entity" && node.origin) {
                        coords = await getCoordinatesForEntity(node.origin, node.name);
                    } else {
                        const parentCoords = parent ? nodes[parent].coords : [0, 0];
                        const offset = 0.05 * (level - 1);
                        const angle = Math.random() * 2 * Math.PI;
                        coords = [
                            parentCoords[0] + offset * Math.cos(angle),
                            parentCoords[1] + offset * Math.sin(angle)
                        ];
                    }
                    
                    nodes[nodeId] = {
                        id: nodeId,
                        name: node.name,
                        type: node.type,
                        subtype: node.subtype,
                        color: node.color,
                        details: node.details,
                        coords: coords,
                        level: level,
                        data: node.data,
                        geoJsonFeature: node.geoJsonFeature,
                        connections: 0
                    };
                    
                    if (parent) {
                        edges.push({
                            from: parent,
                            to: nodeId,
                            type: node.type === "relationship" ? "contains" : node.subtype || "relationship",
                            color: node.color,
                            level: level
                        });
                    }
                    
                    if (node.children) {
                        node.children.forEach(child => {
                            nodeQueue.push({node: child, parent: nodeId, level: level + 1});
                        });
                    }
                }
                
                edges.forEach(edge => {
                    if (nodes[edge.from]) nodes[edge.from].connections++;
                    if (nodes[edge.to]) nodes[edge.to].connections++;
                });
                
                return {nodes, edges};
            }

            // Load and parse CSV data
            async function loadData() {
                try {
                    let csvText = fallbackCsvData;
                    let geoJsonData = null;
                    
                    // Try to load CSV from GitHub
                    try {
                        console.log("Loading CSV from GitHub...");
                        const csvResponse = await fetch(csvUrl);
                        if (csvResponse.ok) {
                            csvText = await csvResponse.text();
                            console.log("Successfully loaded CSV from GitHub");
                        } else {
                            console.warn("Failed to load CSV from GitHub, using fallback data");
                        }
                    } catch (error) {
                        console.warn("Error loading CSV from GitHub:", error);
                    }
                    
                    // Try to load GeoJSON from GitHub
                    try {
                        console.log("Loading GeoJSON from GitHub...");
                        const geoJsonResponse = await fetch(geoJsonUrl);
                        if (geoJsonResponse.ok) {
                            geoJsonData = await geoJsonResponse.json();
                            console.log("Successfully loaded GeoJSON from GitHub, features:", geoJsonData.features.length);
                        } else {
                            console.warn("Failed to load GeoJSON from GitHub");
                        }
                    } catch (error) {
                        console.warn("Error loading GeoJSON from GitHub:", error);
                    }
                    
                    // Process GeoJSON data
                    const geoJsonByApn = {};
                    if (geoJsonData && geoJsonData.features) {
                        geoJsonData.features.forEach(feature => {
                            if (feature.properties && feature.properties.apn) {
                                geoJsonByApn[feature.properties.apn] = feature;
                            }
                        });
                        console.log("Indexed GeoJSON features by APN:", Object.keys(geoJsonByApn));
                    }
                    
                    // Fix CSV header
                    const lines = csvText.split('\n');
                    const fixedHeader = "Category,Assessor parcel number,Building classification,Year built/approved,Acres,Building sq.ft.,Developer,DevOriginCity,Purchaser/Merger,Transaction Type,Leasee,PurchaserOriginCity,LeaseeOriginCity,Endpoint";
                    lines[0] = fixedHeader;
                    const fixedCsv = lines.join('\n');
                    
                    const parsed = Papa.parse(fixedCsv, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true
                    });

                    const mindMapData = buildMindMapData(parsed.data, geoJsonByApn);
                    const {nodes, edges} = await convertMindMapToNetwork(mindMapData, geoJsonByApn);
                    
                    const warehouses = Object.values(nodes).filter(n => n.type === 'warehouse');
                    const stats = {
                        totalWarehouses: warehouses.length,
                        totalAcres: warehouses.reduce((sum, w) => sum + (w.data?.Acres || 0), 0),
                        totalSqft: warehouses.reduce((sum, w) => sum + (w.data?.["Building sq.ft."] || 0), 0),
                        developers: Object.values(nodes).filter(n => n.subtype === 'developer').length,
                        purchasers: Object.values(nodes).filter(n => n.subtype === 'purchaser').length,
                        leasees: Object.values(nodes).filter(n => n.subtype === 'leasee').length,
                        geoJsonFeatures: Object.keys(geoJsonByApn).length
                    };

                    console.log("Data processing complete. Nodes:", Object.keys(nodes).length, "Edges:", edges.length, "GeoJSON features:", stats.geoJsonFeatures);
                    return { nodes, edges, mindMapData, stats, geoJsonByApn };
                } catch (error) {
                    console.error("Error loading data:", error);
                    throw error;
                }
            }

            // Initialize map and create network
            async function initializeMap() {
                try {
                    const map = new Map({
                        basemap: "gray-vector"
                    });

                    const view = new MapView({
                        container: "viewDiv",
                        map: map,
                        center: [-117.396, 34.070],
                        zoom: 11
                    });

                    const warehouseLayer = new GraphicsLayer({ title: "Warehouse Footprints" });
                    const edgeLayer = new GraphicsLayer({ title: "Connections" });
                    const nodeLayer = new GraphicsLayer({ title: "Entities" });
                    const labelLayer = new GraphicsLayer({ title: "Labels" });
                    
                    map.addMany([warehouseLayer, edgeLayer, nodeLayer, labelLayer]);

                    await view.when();

                    const { nodes, edges, mindMapData, stats, geoJsonByApn } = await loadData();
                    
                    // Update statistics panel
                    document.getElementById("statsSection").innerHTML = `
                        <div><strong>${stats.totalWarehouses}</strong> Warehouse Properties</div>
                        <div><strong>${stats.totalAcres.toLocaleString()}</strong> Total Acres</div>
                        <div><strong>${(stats.totalSqft / 1000000).toFixed(1)}M</strong> Total Sq.Ft.</div>
                        <div style="margin-top: 5px;">
                            <strong>${stats.developers}</strong> Developers • 
                            <strong>${stats.purchasers}</strong> Purchasers • 
                            <strong>${stats.leasees}</strong> Leasees
                        </div>
                        <div style="margin-top: 5px; font-size: 11px; color: #666;">
                            <strong>${stats.geoJsonFeatures}</strong> warehouse footprints loaded
                        </div>
                    `;
                    
                    // Add warehouse footprints from GeoJSON
                    console.log("Adding warehouse footprints...");
                    let footprintCount = 0;
                    Object.entries(geoJsonByApn).forEach(([apn, feature]) => {
                        if (feature.geometry && (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon')) {
                            try {
                                let rings;
                                if (feature.geometry.type === 'MultiPolygon') {
                                    // For MultiPolygon, flatten all polygons
                                    rings = [];
                                    feature.geometry.coordinates.forEach(polygon => {
                                        rings.push(...polygon);
                                    });
                                } else {
                                    rings = feature.geometry.coordinates;
                                }
                                
                                const polygon = new Polygon({
                                    rings: rings,
                                    spatialReference: { wkid: 4326 }
                                });
                                
                                const fillSymbol = new SimpleFillSymbol({
                                    color: [139, 69, 19, 0.3], // Brown with transparency
                                    outline: {
                                        color: [139, 69, 19],
                                        width: 2
                                    }
                                });
                                
                                const polygonGraphic = new Graphic({
                                    geometry: polygon,
                                    symbol: fillSymbol,
                                    attributes: {
                                        apn: apn,
                                        warehouseData: feature.properties,
                                        type: 'warehousePolygon'
                                    }
                                });
                                
                                warehouseLayer.add(polygonGraphic);
                                footprintCount++;
                            } catch (error) {
                                console.error(`Error adding polygon for APN ${apn}:`, error);
                            }
                        }
                    });
                    console.log(`Added ${footprintCount} warehouse footprints`);
                    
                    // Create edge graphics
                    edges.forEach(edge => {
                        const fromNode = nodes[edge.from];
                        const toNode = nodes[edge.to];
                        
                        if (fromNode && toNode) {
                            const polyline = new Polyline({
                                paths: [[fromNode.coords, toNode.coords]],
                                spatialReference: { wkid: 4326 }
                            });
                            
                            let color, width, style;
                            if (edge.type === "contains" && fromNode.type === "root") {
                                color = [139, 69, 19, 0.8];
                                width = 4;
                                style = "solid";
                            } else if (edge.type === "contains") {
                                color = edge.color ? hexToRgba(edge.color, 0.6) : [149, 165, 166, 0.6];
                                width = 2;
                                style = "solid";
                            } else if (edge.type === "developer") {
                                color = [46, 134, 193, 0.8];
                                width = 3;
                                style = "solid";
                            } else if (edge.type === "purchaser") {
                                color = [231, 76, 60, 0.8];
                                width = 3;
                                style = "solid";
                            } else if (edge.type === "leasee") {
                                color = [243, 156, 18, 0.8];
                                width = 3;
                                style = "solid";
                            } else {
                                color = [149, 165, 166, 0.8];
                                width = 2;
                                style = "dash";
                            }
                            
                            const lineSymbol = new SimpleLineSymbol({
                                color: color,
                                width: width,
                                style: style
                            });
                            
                            const graphic = new Graphic({
                                geometry: polyline,
                                symbol: lineSymbol,
                                attributes: edge
                            });
                            
                            edgeLayer.add(graphic);
                        }
                    });

                    // Create node graphics
                    Object.keys(nodes).forEach(nodeKey => {
                        const node = nodes[nodeKey];
                        const point = new Point({
                            longitude: node.coords[0],
                            latitude: node.coords[1],
                            spatialReference: { wkid: 4326 }
                        });
                        
                        let size = 10;
                        let color = hexToRgb(node.color || "#999999");
                        
                        if (node.type === "root") {
                            size = 24;
                        } else if (node.type === "warehouse") {
                            size = 16;
                        } else if (node.type === "relationship") {
                            size = 8;
                        } else if (node.type === "entity") {
                            size = 12 + Math.min(node.connections * 2, 8);
                        }
                        
                        const markerSymbol = new SimpleMarkerSymbol({
                            color: color,
                            size: size,
                            outline: {
                                color: [255, 255, 255],
                                width: 2
                            }
                        });
                        
                        const graphic = new Graphic({
                            geometry: point,
                            symbol: markerSymbol,
                            attributes: node
                        });
                        
                        nodeLayer.add(graphic);
                        
                        // Add labels for important nodes
                        if (node.type === "root" || node.type === "warehouse" || 
                            (node.type === "entity" && node.connections > 0)) {
                            let labelText = node.name;
                            if (node.type === "warehouse") {
                                labelText = node.id.length > 10 ? "WH" : node.id;
                            }
                            
                            const textSymbol = new TextSymbol({
                                text: labelText,
                                color: [0, 0, 0],
                                haloColor: [255, 255, 255],
                                haloSize: 2,
                                font: {
                                    size: node.type === "root" ? 14 : 
                                          (node.type === "warehouse" ? 9 : 10),
                                    weight: node.type === "root" ? "bold" : "normal"
                                },
                                yoffset: -15
                            });
                            
                            const labelGraphic = new Graphic({
                                geometry: point,
                                symbol: textSymbol
                            });
                            
                            labelLayer.add(labelGraphic);
                        }
                    });
                    
                    // Hide loading and show info panel
                    document.getElementById("loadingDiv").style.display = "none";
                    document.getElementById("infoPanel").style.display = "block";
                    
                    // Update extent to show all graphics
                    if (nodeLayer.graphics.length > 0) {
                        view.goTo(nodeLayer.graphics.concat(edgeLayer.graphics).concat(warehouseLayer.graphics), {
                            padding: { top: 50, bottom: 50, left: 50, right: 400 }
                        });
                    }
                    
                    // Handle click events
                    view.on("click", function(event) {
                        view.hitTest(event).then(function(response) {
                            const graphic = response.results[0]?.graphic;
                            if (graphic && graphic.attributes) {
                                const attrs = graphic.attributes;
                                let infoHtml = "";
                                
                                if (attrs.type === "root") {
                                    infoHtml = `<h4>${attrs.name}</h4>`;
                                    infoHtml += `<div class="warehouse-details">${attrs.details}</div>`;
                                    infoHtml += `<p><strong>Total Warehouses:</strong> ${mindMapData.children.length}</p>`;
                                    
                                } else if (attrs.type === "warehouse") {
                                    const warehouseData = attrs.data;
                                    infoHtml = `<h4>Warehouse: ${attrs.id}</h4>`;
                                    infoHtml += `<div class="warehouse-details">`;
                                    infoHtml += `<div>${attrs.details}</div>`;
                                    
                                    // Add GeoJSON-based info if available
                                    if (attrs.geoJsonFeature && attrs.geoJsonFeature.properties) {
                                        const props = attrs.geoJsonFeature.properties;
                                        if (props.shape_area) {
                                            infoHtml += `<div><strong>Area:</strong> ${(props.shape_area / 43560).toFixed(1)} acres (${props.shape_area.toLocaleString()} sq.ft.)</div>`;
                                        }
                                    }
                                    
                                    if (warehouseData?.Category) {
                                        infoHtml += `<div><strong>Status:</strong> ${warehouseData.Category}</div>`;
                                    }
                                    if (warehouseData?.["Year built/approved"]) {
                                        infoHtml += `<div><strong>Year:</strong> ${warehouseData["Year built/approved"]}</div>`;
                                    }
                                    infoHtml += `</div>`;
                                    
                                    // Find and display the mind map branch for this warehouse
                                    const warehouseBranch = mindMapData.children.find(w => 
                                        w.name === attrs.id || w.name === attrs.name
                                    );
                                    
                                    if (warehouseBranch && warehouseBranch.children.length > 0) {
                                        infoHtml += `<h5>Ownership Structure:</h5>`;
                                        warehouseBranch.children.forEach(branch => {
                                            infoHtml += `<div class="mind-map-branch" style="border-left-color: ${branch.color};">`;
                                            infoHtml += `<div class="branch-title">${branch.name}</div>`;
                                            infoHtml += `<div class="branch-details">${branch.details}</div>`;
                                            if (branch.children && branch.children.length > 0) {
                                                infoHtml += `<div class="tree-structure">`;
                                                branch.children.forEach(entity => {
                                                    infoHtml += `<div class="tree-node">`;
                                                    infoHtml += `<strong>${entity.name}</strong><br>`;
                                                    infoHtml += `<span style="font-size: 11px;">${entity.details}</span>`;
                                                    infoHtml += `</div>`;
                                                });
                                                infoHtml += `</div>`;
                                            }
                                            infoHtml += `</div>`;
                                        });
                                    }
                                    
                                } else if (attrs.warehouseData || attrs.type === 'warehousePolygon') {
                                    // Clicked on warehouse polygon
                                    const props = attrs.warehouseData;
                                    infoHtml = `<h4>Warehouse: ${props.apn}</h4>`;
                                    infoHtml += `<div class="warehouse-details">`;
                                    infoHtml += `<div><strong>Classification:</strong> ${props.class || props.building_classification || 'N/A'}</div>`;
                                    infoHtml += `<div><strong>Year Built:</strong> ${props.year_built || 'N/A'}</div>`;
                                    infoHtml += `<div><strong>Category:</strong> ${props.category || 'N/A'}</div>`;
                                    if (props.shape_area) {
                                        infoHtml += `<div><strong>Area:</strong> ${(props.shape_area / 43560).toFixed(1)} acres (${props.shape_area.toLocaleString()} sq.ft.)</div>`;
                                    }
                                    infoHtml += `</div>`;
                                    
                                    // Try to find corresponding node data
                                    const warehouseNode = Object.values(nodes).find(n => 
                                        n.type === 'warehouse' && (n.name === props.apn || n.id === props.apn)
                                    );
                                    
                                    if (warehouseNode && warehouseNode.data) {
                                        const warehouseData = warehouseNode.data;
                                        infoHtml += `<h5>Ownership Information:</h5>`;
                                        
                                        if (warehouseData.Developer) {
                                            infoHtml += `<div class="branch-details"><strong>Developer:</strong> ${warehouseData.Developer}</div>`;
                                        }
                                        if (warehouseData["Purchaser/Merger"]) {
                                            infoHtml += `<div class="branch-details"><strong>Owner:</strong> ${warehouseData["Purchaser/Merger"]}</div>`;
                                        }
                                        if (warehouseData.Leasee) {
                                            infoHtml += `<div class="branch-details"><strong>Tenant:</strong> ${warehouseData.Leasee}</div>`;
                                        }
                                    }
                                    
                                } else if (attrs.type === "relationship") {
                                    infoHtml = `<h4>${attrs.name}</h4>`;
                                    infoHtml += `<p>${attrs.details}</p>`;
                                    
                                } else if (attrs.type === "entity") {
                                    infoHtml = `<h4>${attrs.name}</h4>`;
                                    infoHtml += `<p><strong>Type:</strong> ${attrs.subtype.charAt(0).toUpperCase() + attrs.subtype.slice(1)}</p>`;
                                    infoHtml += `<p>${attrs.details}</p>`;
                                    if (attrs.connections > 0) {
                                        infoHtml += `<p><strong>Connections:</strong> ${attrs.connections}</p>`;
                                    }
                                    
                                } else if (attrs.from && attrs.to) {
                                    infoHtml = `<h4>Connection</h4>`;
                                    infoHtml += `<p><strong>From:</strong> ${attrs.from}</p>`;
                                    infoHtml += `<p><strong>To:</strong> ${attrs.to}</p>`;
                                    infoHtml += `<p><strong>Type:</strong> ${attrs.type}</p>`;
                                }
                                
                                document.getElementById("nodeInfo").innerHTML = infoHtml || "<p>Click on nodes for details</p>";
                            }
                        });
                    });
                    
                    // Add keyboard shortcuts
                    view.on("key-down", function(event) {
                        if (event.key === "r" || event.key === "R") {
                            view.goTo(nodeLayer.graphics.concat(edgeLayer.graphics).concat(warehouseLayer.graphics), {
                                padding: { top: 50, bottom: 50, left: 50, right: 400 }
                            });
                        } else if (event.key === "c" || event.key === "C") {
                            view.goTo({
                                center: cityCoords["Bloomington, CA"],
                                zoom: 11
                            });
                        }
                    });
                    
                } catch (error) {
                    console.error("Failed to initialize map:", error);
                    document.getElementById("loadingDiv").style.display = "none";
                    document.getElementById("errorDiv").style.display = "block";
                    document.getElementById("errorMessage").textContent = error.message;
                }
            }
            
            // Helper function to convert hex to RGB
            function hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? [
                    parseInt(result[1], 16),
                    parseInt(result[2], 16),
                    parseInt(result[3], 16)
                ] : [128, 128, 128];
            }
            
            // Helper function to convert hex to RGBA
            function hexToRgba(hex, alpha) {
                const rgb = hexToRgb(hex);
                return [...rgb, alpha];
            }

            // Start the application
            initializeMap();
        });
    </script>
</body>
</html>
