<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>Bloomington Warehouse Ownership Network Map</title>
    
    <link rel="stylesheet" href="https://js.arcgis.com/4.27/esri/themes/light/main.css">
    <style>
        html, body, #viewDiv {
            padding: 0;
            margin: 0;
            height: 100%;
            width: 100%;
        }
        
        #infoPanel {
            position: absolute;
            top: 15px;
            right: 15px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            max-width: 380px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 99;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        
        .legend-line {
            width: 30px;
            height: 3px;
            margin-right: 10px;
        }
        
        .legend-circle {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
            border: 2px solid white;
            box-shadow: 0 0 2px rgba(0,0,0,0.3);
        }
        
        .node-info {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #ddd;
        }
        
        .warehouse-details {
            background: #f5f5f5;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 13px;
        }
        
        .mind-map-branch {
            margin: 10px 0;
            padding: 10px;
            background: #f9f9f9;
            border-left: 4px solid #3498db;
            border-radius: 4px;
        }
        
        .branch-title {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .branch-details {
            font-size: 12px;
            color: #555;
            margin: 5px 0;
        }
        
        #loadingDiv {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        
        #errorDiv {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            display: none;
            max-width: 400px;
        }
        
        .stats-section {
            background: #e8f4f8;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-size: 13px;
        }
        
        .warehouse-node-legend {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #ddd;
        }
        
        .tree-structure {
            margin-left: 15px;
            border-left: 2px solid #ddd;
            padding-left: 10px;
        }
        
        .tree-node {
            margin: 5px 0;
            position: relative;
        }
        
        .tree-node::before {
            content: "";
            position: absolute;
            left: -12px;
            top: 10px;
            width: 10px;
            height: 1px;
            background: #ddd;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://js.arcgis.com/4.27/"></script>
</head>
<body>
    <div id="viewDiv"></div>
    <div id="loadingDiv">
        <h3>Loading Network Map...</h3>
        <p>Processing warehouse ownership data</p>
    </div>
    <div id="errorDiv">
        <h3>Error Loading Data</h3>
        <p id="errorMessage"></p>
    </div>
    <div id="infoPanel" style="display: none;">
        <h3>Warehouse Ownership Network</h3>
        <p><strong>Bloomington, CA</strong></p>
        
        <div class="stats-section" id="statsSection">
            <!-- Stats will be populated dynamically -->
        </div>
        
        <div class="legend">
            <h4>Entity Types</h4>
            <div class="legend-item">
                <div class="legend-circle" style="background: #34495e;"></div>
                <span>Central Hub (Bloomington)</span>
            </div>
            <div class="legend-item">
                <div class="legend-circle" style="background: #8B4513;"></div>
                <span>Warehouse Property</span>
            </div>
            <div class="legend-item">
                <div class="legend-circle" style="background: #2E86C1;"></div>
                <span>Developer</span>
            </div>
            <div class="legend-item">
                <div class="legend-circle" style="background: #E74C3C;"></div>
                <span>Purchaser/Owner</span>
            </div>
            <div class="legend-item">
                <div class="legend-circle" style="background: #F39C12;"></div>
                <span>Leasee/Tenant</span>
            </div>
            <div class="legend-item">
                <div class="legend-circle" style="background: #3498DB;"></div>
                <span>City/Headquarters</span>
            </div>
        </div>
        
        <div class="warehouse-node-legend">
            <h4>Connection Types</h4>
            <div class="legend-item">
                <div class="legend-line" style="background: #8B4513; width: 4px;"></div>
                <span>Contains Warehouse</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #2E86C1; width: 4px;"></div>
                <span>Developed by</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #E74C3C; width: 4px;"></div>
                <span>Purchased/Merged</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #F39C12; width: 3px;"></div>
                <span>Leased to</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #27AE60; width: 2px; border-style: dashed;"></div>
                <span>Headquartered in</span>
            </div>
        </div>
        
        <div class="node-info" id="nodeInfo">
            <p>Click on nodes for details</p>
        </div>
    </div>

    <script>
        // GitHub content URLs for CSV files
        const githubBaseUrl = "https://raw.githubusercontent.com/pluricalifornia/BloomingtonWarehouses/main/";
        
        // Flag to control using static data vs GitHub data
        let useStaticData = false; // Set to false to attempt GitHub loading
        
        // Static CSV data embedded in the HTML as a fallback
        const csvData = `"Category","Assessor parcel number","Building classification","Year built/approved","Acres","Building sq.ft.",Developer,DevOriginCity,Purchaser/Merger,Category,Leasee,PurchaserOriginCity,LeaseeOriginCity,Endpoint
"Approved","Bloomington Business Park","https://ceqanet.opr.ca.gov/2020120545/3","2025","181","4340000",Howard Industrial Partners LLC,"Lemon Heights, CA",TBD,TBD,TBD,TBD,TBD,"Bloomington, CA"
"Existing","025217367","transit warehouse (truck terminal)","2001","47","1133000",Pacific Industrial,"Newport Beach, CA",Realterm,Purchase,YellowCorp,"Annapolis, MD",TBD,"Bloomington, CA"
"Existing","Bloomington Logistics Center","distribution warehouse","2019","35","827000", Crow holdings Industrial, "Highland Park, TX", ASB Real Estate Investments,Purchase,TBD,"Bethseda, MD",TBD,"Bloomington, CA"
"Existing","025215217","distribution warehouse","2018","28","674000", DCT Industrial Trust,"Evergreen, CO",Prologis,Merger,TBD,"Pacific Heights, CA",TBD,"Bloomington, CA"`;

        require([
            "esri/Map",
            "esri/views/MapView",
            "esri/Graphic",
            "esri/layers/GraphicsLayer",
            "esri/geometry/Point",
            "esri/geometry/Polyline",
            "esri/symbols/SimpleMarkerSymbol",
            "esri/symbols/SimpleLineSymbol",
            "esri/symbols/TextSymbol",
            "esri/rest/locator",
            "esri/rest/support/AddressCandidate",
            "esri/widgets/Popup"
        ], function(Map, MapView, Graphic, GraphicsLayer, Point, Polyline, 
                   SimpleMarkerSymbol, SimpleLineSymbol, TextSymbol, locator, AddressCandidate, Popup) {

            // Cache for geocoded locations
            const geocodeCache = {};
            
            // Predefined coordinates for known cities (fallback)
            const cityCoords = {
                "Bloomington, CA": [-117.396, 34.070],
                "Lemon Heights, CA": [-117.823, 33.765],
                "Newport Beach, CA": [-117.928, 33.618],
                "Annapolis, MD": [-76.492, 38.978],
                "Highland Park, TX": [-96.792, 32.834],
                "Bethesda, MD": [-77.094, 38.984],
                "Bethseda, MD": [-77.094, 38.984], // Handle typo
                "Evergreen, CO": [-105.321, 39.633],
                "Pacific Heights, CA": [-122.447, 37.794],
                "San Francisco, CA": [-122.419, 37.774],
                "Denver, CO": [-104.990, 39.739],
                "Irvine, CA": [-117.826, 33.684],
                "Costa Mesa, CA": [-117.919, 33.641],
                "City of Industry, CA": [-117.958, 34.019],
                "Santa Ana, CA": [-117.868, 33.745],
                "Newport, CA": [-117.928, 33.618],
                "Dallas, TX": [-96.797, 32.777],
                "Los Angeles, CA": [-118.243, 34.052],
                "Chicago, IL": [-87.629, 41.878],
                "New York, NY": [-74.006, 40.713],
                "Washington, DC": [-77.036, 38.895],
                "Miami Beach, FL": [-80.130, 25.790],
                "Allisonville, IN": [-86.004, 39.977],
                "Arcadia, AZ": [-111.093, 33.502],
                "Manhattan, NY": [-73.966, 40.783],
                "Belvedere Tiburon, CA": [-122.456, 37.873],
                "Lake Highlands, TX": [-96.720, 32.885],
                "Pacific Palisades, CA": [-118.535, 34.046],
                "Palm Springs, CA": [-116.545, 33.830],
                "Alessandro Heights, CA": [-117.274, 33.914],
                "La Cañada Flintridge, CA": [-118.200, 34.207],
                "Mentone, CA": [-117.120, 34.065],
                "Newport Coast, CA": [-117.837, 33.600],
                "Brentwood, CA": [-118.472, 34.058],
                "Kihei, HI": [-156.447, 20.785]
            };

            // Geocoding function using ArcGIS locator
            async function geocodeLocation(address) {
                // Check cache first
                if (geocodeCache[address]) {
                    return geocodeCache[address];
                }
                
                // Check predefined coordinates
                if (cityCoords[address]) {
                    geocodeCache[address] = cityCoords[address];
                    return cityCoords[address];
                }
                
                try {
                    // Use ArcGIS geocoding service
                    const geocodeUrl = "https://geocode-api.arcgis.com/arcgis/rest/services/World/GeocodeServer";
                    const result = await locator.addressToLocations(geocodeUrl, {
                        address: {
                            SingleLine: address
                        },
                        maxLocations: 1
                    });
                    
                    if (result && result.length > 0) {
                        const coords = [result[0].location.longitude, result[0].location.latitude];
                        geocodeCache[address] = coords;
                        return coords;
                    }
                } catch (error) {
                    console.warn(`Geocoding failed for ${address}:`, error);
                }
                
                // Fallback to default location with offset
                const defaultCoords = [-117.4 + (Math.random() - 0.5) * 2, 34.0 + (Math.random() - 0.5) * 2];
                geocodeCache[address] = defaultCoords;
                return defaultCoords;
            }

            // Function to get coordinates with offset for multiple entities
            const entityOffsets = {};
            async function getCoordinatesForEntity(location, entityName) {
                const baseCoords = await geocodeLocation(location);
                
                // Add offset for multiple entities in same location
                const key = location + "|" + entityName;
                if (!entityOffsets[key]) {
                    const count = Object.keys(entityOffsets).filter(k => k.startsWith(location)).length;
                    const angle = (count * 72) * Math.PI / 180;
                    const offset = 0.05; // Smaller offset for cleaner appearance
                    entityOffsets[key] = [
                        baseCoords[0] + offset * Math.cos(angle),
                        baseCoords[1] + offset * Math.sin(angle)
                    ];
                }
                return entityOffsets[key];
            }

            // Helper function to clean location strings
            function cleanLocation(location) {
                if (!location || typeof location !== 'string') return null;
                
                // Remove extra quotes and whitespace
                let cleaned = location.trim().replace(/["\\"]/g, '').trim();
                
                // List of invalid location values to filter out
                const invalidLocations = ['TBD', 'TBA', 'N/A', 'CA', 'TX', 'Florida', 'Unknown', ''];
                if (invalidLocations.includes(cleaned)) return null;
                
                // Fix common issues
                if (cleaned === 'Bethseda, MD') cleaned = 'Bethesda, MD';
                
                // Add state to city names that are missing it
                const cityStateMap = {
                    'Highland Park': 'Highland Park, TX',
                    'Miami Beach': 'Miami Beach, FL',
                    'Alessandro Heights': 'Alessandro Heights, CA',
                    'La Cañada Flintridge': 'La Cañada Flintridge, CA',
                    'Mentone': 'Mentone, CA',
                    'Newport Coast': 'Newport Coast, CA'
                };
                
                if (cityStateMap[cleaned]) {
                    cleaned = cityStateMap[cleaned];
                }
                
                return cleaned;
            }
            
            // Helper function to clean entity names
            function cleanEntityName(name) {
                if (!name || typeof name !== 'string') return null;
                
                // Remove extra quotes and whitespace
                let cleaned = name.trim().replace(/["\\"]/g, '').trim();
                
                // Filter out invalid entity names
                const invalidNames = ['TBD', 'TBA', 'N/A', 'Purchase', 'Merger', ''];
                if (invalidNames.includes(cleaned)) return null;
                
                return cleaned;
            }

            // Generate warehouse node position around Bloomington
            function getWarehousePosition(index, total) {
                const bloomingtonCoords = cityCoords["Bloomington, CA"];
                const radius = 0.15; // Radius around Bloomington for warehouse placement
                const angle = (index / total) * 2 * Math.PI;
                
                return [
                    bloomingtonCoords[0] + radius * Math.cos(angle),
                    bloomingtonCoords[1] + radius * Math.sin(angle)
                ];
            }

            // Build mind map data structure
            function buildMindMapData(parsedData) {
                const mindMapData = {
                    name: "Bloomington, CA",
                    color: "#34495e",
                    details: "Central hub for warehouse development in San Bernardino County",
                    type: "root",
                    children: []
                };

                parsedData.forEach((row, index) => {
                    const warehouseId = row["Assessor parcel number"] || `Warehouse_${index}`;
                    const developer = cleanEntityName(row.Developer);
                    const purchaser = cleanEntityName(row["Purchaser/Merger"]);
                    const leasee = cleanEntityName(row.Leasee);
                    
                    const warehouseNode = {
                        name: warehouseId,
                        color: "#8B4513",
                        details: `${row["Building classification"] || "Warehouse"} - ${row.Acres || 0} acres, ${(row["Building sq.ft."] || 0).toLocaleString()} sq.ft.`,
                        type: "warehouse",
                        data: row,
                        children: []
                    };

                    // Add developer branch
                    if (developer) {
                        const devOrigin = cleanLocation(row.DevOriginCity);
                        warehouseNode.children.push({
                            name: "Developer",
                            color: "#2E86C1",
                            details: developer,
                            type: "relationship",
                            children: [
                                {
                                    name: developer,
                                    color: "#2E86C1",
                                    details: `Headquarters: ${devOrigin || "Unknown"}`,
                                    type: "entity",
                                    subtype: "developer",
                                    origin: devOrigin
                                }
                            ]
                        });
                    }

                    // Add purchaser branch
                    if (purchaser) {
                        const purchOrigin = cleanLocation(row.PurchaserOriginCity);
                        warehouseNode.children.push({
                            name: "Purchaser/Owner",
                            color: "#E74C3C",
                            details: `${row["Transaction Type"] || "Purchase"}: ${purchaser}`,
                            type: "relationship",
                            children: [
                                {
                                    name: purchaser,
                                    color: "#E74C3C",
                                    details: `Headquarters: ${purchOrigin || "Unknown"}`,
                                    type: "entity",
                                    subtype: "purchaser",
                                    origin: purchOrigin
                                }
                            ]
                        });
                    }

                    // Add leasee branch
                    if (leasee) {
                        const leaseeOrigin = cleanLocation(row.LeaseeOriginCity);
                        warehouseNode.children.push({
                            name: "Tenant",
                            color: "#F39C12",
                            details: `Leased to: ${leasee}`,
                            type: "relationship",
                            children: [
                                {
                                    name: leasee,
                                    color: "#F39C12",
                                    details: `Headquarters: ${leaseeOrigin || "Unknown"}`,
                                    type: "entity",
                                    subtype: "leasee",
                                    origin: leaseeOrigin
                                }
                            ]
                        });
                    }

                    mindMapData.children.push(warehouseNode);
                });

                return mindMapData;
            }

            // Convert mind map structure to nodes and edges for visualization
            async function convertMindMapToNetwork(mindMapData) {
                const nodes = {};
                const edges = [];
                const nodeQueue = [{node: mindMapData, parent: null, level: 0}];
                
                // Process mind map structure breadth-first
                while (nodeQueue.length > 0) {
                    const {node, parent, level} = nodeQueue.shift();
                    let nodeId = node.name;
                    
                    // Create unique IDs for duplicate names
                    if (nodes[nodeId]) {
                        nodeId = `${node.name}_${Object.keys(nodes).filter(k => k.startsWith(node.name)).length}`;
                    }
                    
                    // Get coordinates based on node type and level
                    let coords;
                    if (node.type === "root") {
                        coords = await geocodeLocation(node.name);
                    } else if (node.type === "warehouse") {
                        const warehouseIndex = mindMapData.children.indexOf(node);
                        coords = getWarehousePosition(warehouseIndex, mindMapData.children.length);
                    } else if (node.type === "entity" && node.origin) {
                        coords = await getCoordinatesForEntity(node.origin, node.name);
                    } else {
                        // Position relationship nodes near their warehouse
                        const parentCoords = parent ? nodes[parent].coords : [0, 0];
                        const offset = 0.05 * (level - 1);
                        const angle = Math.random() * 2 * Math.PI;
                        coords = [
                            parentCoords[0] + offset * Math.cos(angle),
                            parentCoords[1] + offset * Math.sin(angle)
                        ];
                    }
                    
                    // Create node
                    nodes[nodeId] = {
                        id: nodeId,
                        name: node.name,
                        type: node.type,
                        subtype: node.subtype,
                        color: node.color,
                        details: node.details,
                        coords: coords,
                        level: level,
                        data: node.data,
                        connections: 0
                    };
                    
                    // Create edge from parent
                    if (parent) {
                        edges.push({
                            from: parent,
                            to: nodeId,
                            type: node.type === "relationship" ? "contains" : node.subtype || "relationship",
                            color: node.color,
                            level: level
                        });
                    }
                    
                    // Process children
                    if (node.children) {
                        node.children.forEach(child => {
                            nodeQueue.push({node: child, parent: nodeId, level: level + 1});
                        });
                    }
                }
                
                // Count connections
                edges.forEach(edge => {
                    if (nodes[edge.from]) nodes[edge.from].connections++;
                    if (nodes[edge.to]) nodes[edge.to].connections++;
                });
                
                return {nodes, edges};
            }

            // Load and parse CSV data
            async function loadData() {
                try {
                    let csvText = csvData;
                    
                    // Try to load from GitHub if not using static data
                    if (!useStaticData) {
                        try {
                            const response = await fetch(githubBaseUrl + "data/WarehouseTracker.csv");
                            if (response.ok) {
                                csvText = await response.text();
                                console.log("Successfully loaded CSV from GitHub");
                            } else {
                                console.warn("Failed to load from GitHub, using embedded data");
                            }
                        } catch (error) {
                            console.warn("Failed to fetch from GitHub, using embedded data:", error);
                        }
                    }
                    
                    // Fix header issue
                    const lines = csvText.split('\n');
                    const fixedHeader = "Category,Assessor parcel number,Building classification,Year built/approved,Acres,Building sq.ft.,Developer,DevOriginCity,Purchaser/Merger,Transaction Type,Leasee,PurchaserOriginCity,LeaseeOriginCity,Endpoint";
                    lines[0] = fixedHeader;
                    const fixedCsv = lines.join('\n');
                    
                    const parsed = Papa.parse(fixedCsv, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true
                    });

                    // Build mind map structure
                    const mindMapData = buildMindMapData(parsed.data);
                    
                    // Convert to network visualization
                    const {nodes, edges} = await convertMindMapToNetwork(mindMapData);
                    
                    // Calculate statistics
                    const warehouses = Object.values(nodes).filter(n => n.type === 'warehouse');
                    const stats = {
                        totalWarehouses: warehouses.length,
                        totalAcres: warehouses.reduce((sum, w) => sum + (w.data?.Acres || 0), 0),
                        totalSqft: warehouses.reduce((sum, w) => sum + (w.data?.["Building sq.ft."] || 0), 0),
                        developers: Object.values(nodes).filter(n => n.subtype === 'developer').length,
                        purchasers: Object.values(nodes).filter(n => n.subtype === 'purchaser').length,
                        leasees: Object.values(nodes).filter(n => n.subtype === 'leasee').length
                    };

                    console.log("Mind map data processing complete. Nodes:", Object.keys(nodes).length, "Edges:", edges.length);
                    return { nodes, edges, mindMapData, stats };
                } catch (error) {
                    console.error("Error loading data:", error);
                    throw error;
                }
            }

            // Initialize map and create network
            async function initializeMap() {
                try {
                    // Initialize map
                    const map = new Map({
                        basemap: "gray-vector"
                    });

                    const view = new MapView({
                        container: "viewDiv",
                        map: map,
                        center: [-117.396, 34.070], // Bloomington, CA
                        zoom: 11
                    });

                    // Create graphics layers
                    const edgeLayer = new GraphicsLayer({ title: "Connections" });
                    const nodeLayer = new GraphicsLayer({ title: "Entities" });
                    const labelLayer = new GraphicsLayer({ title: "Labels" });
                    
                    map.addMany([edgeLayer, nodeLayer, labelLayer]);

                    // Wait for view to be ready
                    await view.when();

                    // Load and process data
                    const { nodes, edges, mindMapData, stats } = await loadData();
                    
                    // Update statistics panel
                    document.getElementById("statsSection").innerHTML = `
                        <div><strong>${stats.totalWarehouses}</strong> Warehouse Properties</div>
                        <div><strong>${stats.totalAcres.toLocaleString()}</strong> Total Acres</div>
                        <div><strong>${(stats.totalSqft / 1000000).toFixed(1)}M</strong> Total Sq.Ft.</div>
                        <div style="margin-top: 5px;">
                            <strong>${stats.developers}</strong> Developers • 
                            <strong>${stats.purchasers}</strong> Purchasers • 
                            <strong>${stats.leasees}</strong> Leasees
                        </div>
                    `;
                    
                    // Create edge graphics
                    edges.forEach(edge => {
                        const fromNode = nodes[edge.from];
                        const toNode = nodes[edge.to];
                        
                        if (fromNode && toNode) {
                            const polyline = new Polyline({
                                paths: [[fromNode.coords, toNode.coords]],
                                spatialReference: { wkid: 4326 }
                            });
                            
                            let color, width, style;
                            if (edge.type === "contains" && fromNode.type === "root") {
                                color = [139, 69, 19, 0.8];
                                width = 4;
                                style = "solid";
                            } else if (edge.type === "contains") {
                                color = edge.color ? hexToRgba(edge.color, 0.6) : [149, 165, 166, 0.6];
                                width = 2;
                                style = "solid";
                            } else if (edge.type === "developer") {
                                color = [46, 134, 193, 0.8];
                                width = 3;
                                style = "solid";
                            } else if (edge.type === "purchaser") {
                                color = [231, 76, 60, 0.8];
                                width = 3;
                                style = "solid";
                            } else if (edge.type === "leasee") {
                                color = [243, 156, 18, 0.8];
                                width = 3;
                                style = "solid";
                            } else {
                                color = [149, 165, 166, 0.8];
                                width = 2;
                                style = "dash";
                            }
                            
                            const lineSymbol = new SimpleLineSymbol({
                                color: color,
                                width: width,
                                style: style
                            });
                            
                            const graphic = new Graphic({
                                geometry: polyline,
                                symbol: lineSymbol,
                                attributes: edge
                            });
                            
                            edgeLayer.add(graphic);
                        }
                    });

                    // Create node graphics
                    Object.keys(nodes).forEach(nodeKey => {
                        const node = nodes[nodeKey];
                        const point = new Point({
                            longitude: node.coords[0],
                            latitude: node.coords[1],
                            spatialReference: { wkid: 4326 }
                        });
                        
                        let size = 10;
                        let color = hexToRgb(node.color || "#999999");
                        
                        // Adjust size based on node type and level
                        if (node.type === "root") {
                            size = 24;
                        } else if (node.type === "warehouse") {
                            size = 16;
                        } else if (node.type === "relationship") {
                            size = 8;
                        } else if (node.type === "entity") {
                            size = 12 + Math.min(node.connections * 2, 8);
                        }
                        
                        const markerSymbol = new SimpleMarkerSymbol({
                            color: color,
                            size: size,
                            outline: {
                                color: [255, 255, 255],
                                width: 2
                            }
                        });
                        
                        const graphic = new Graphic({
                            geometry: point,
                            symbol: markerSymbol,
                            attributes: node
                        });
                        
                        nodeLayer.add(graphic);
                        
                        // Add labels for important nodes
                        if (node.type === "root" || node.type === "warehouse" || 
                            (node.type === "entity" && node.connections > 0)) {
                            let labelText = node.name;
                            if (node.type === "warehouse") {
                                labelText = node.id.length > 10 ? "WH" : node.id;
                            }
                            
                            const textSymbol = new TextSymbol({
                                text: labelText,
                                color: [0, 0, 0],
                                haloColor: [255, 255, 255],
                                haloSize: 2,
                                font: {
                                    size: node.type === "root" ? 14 : 
                                          (node.type === "warehouse" ? 9 : 10),
                                    weight: node.type === "root" ? "bold" : "normal"
                                },
                                yoffset: -15
                            });
                            
                            const labelGraphic = new Graphic({
                                geometry: point,
                                symbol: textSymbol
                            });
                            
                            labelLayer.add(labelGraphic);
                        }
                    });
                    
                    // Hide loading and show info panel
                    document.getElementById("loadingDiv").style.display = "none";
                    document.getElementById("infoPanel").style.display = "block";
                    
                    // Update extent to show all graphics
                    if (nodeLayer.graphics.length > 0) {
                        view.goTo(nodeLayer.graphics.concat(edgeLayer.graphics), {
                            padding: { top: 50, bottom: 50, left: 50, right: 400 }
                        });
                    }
                    
                    // Handle click events
                    view.on("click", function(event) {
                        view.hitTest(event).then(function(response) {
                            const graphic = response.results[0]?.graphic;
                            if (graphic && graphic.attributes) {
                                const attrs = graphic.attributes;
                                let infoHtml = "";
                                
                                if (attrs.type === "root") {
                                    // Root node clicked
                                    infoHtml = `<h4>${attrs.name}</h4>`;
                                    infoHtml += `<div class="warehouse-details">${attrs.details}</div>`;
                                    infoHtml += `<p><strong>Total Warehouses:</strong> ${mindMapData.children.length}</p>`;
                                    
                                } else if (attrs.type === "warehouse") {
                                    // Warehouse node clicked - show complete mind map branch
                                    const warehouseData = attrs.data;
                                    infoHtml = `<h4>Warehouse: ${attrs.id}</h4>`;
                                    infoHtml += `<div class="warehouse-details">`;
                                    infoHtml += `<div>${attrs.details}</div>`;
                                    if (warehouseData?.Category) {
                                        infoHtml += `<div><strong>Status:</strong> ${warehouseData.Category}</div>`;
                                    }
                                    if (warehouseData?.["Year built/approved"]) {
                                        infoHtml += `<div><strong>Year:</strong> ${warehouseData["Year built/approved"]}</div>`;
                                    }
                                    infoHtml += `</div>`;
                                    
                                    // Find and display the mind map branch for this warehouse
                                    const warehouseBranch = mindMapData.children.find(w => 
                                        w.name === attrs.id || w.name === attrs.name
                                    );
                                    
                                    if (warehouseBranch && warehouseBranch.children.length > 0) {
                                        infoHtml += `<h5>Ownership Structure:</h5>`;
                                        warehouseBranch.children.forEach(branch => {
                                            infoHtml += `<div class="mind-map-branch" style="border-left-color: ${branch.color};">`;
                                            infoHtml += `<div class="branch-title">${branch.name}</div>`;
                                            infoHtml += `<div class="branch-details">${branch.details}</div>`;
                                            if (branch.children && branch.children.length > 0) {
                                                infoHtml += `<div class="tree-structure">`;
                                                branch.children.forEach(entity => {
                                                    infoHtml += `<div class="tree-node">`;
                                                    infoHtml += `<strong>${entity.name}</strong><br>`;
                                                    infoHtml += `<span style="font-size: 11px;">${entity.details}</span>`;
                                                    infoHtml += `</div>`;
                                                });
                                                infoHtml += `</div>`;
                                            }
                                            infoHtml += `</div>`;
                                        });
                                    }
                                    
                                } else if (attrs.type === "relationship") {
                                    // Relationship node clicked
                                    infoHtml = `<h4>${attrs.name}</h4>`;
                                    infoHtml += `<p>${attrs.details}</p>`;
                                    
                                } else if (attrs.type === "entity") {
                                    // Entity node clicked
                                    infoHtml = `<h4>${attrs.name}</h4>`;
                                    infoHtml += `<p><strong>Type:</strong> ${attrs.subtype.charAt(0).toUpperCase() + attrs.subtype.slice(1)}</p>`;
                                    infoHtml += `<p>${attrs.details}</p>`;
                                    if (attrs.connections > 0) {
                                        infoHtml += `<p><strong>Connections:</strong> ${attrs.connections}</p>`;
                                    }
                                    
                                } else if (attrs.from && attrs.to) {
                                    // Edge clicked
                                    infoHtml = `<h4>Connection</h4>`;
                                    infoHtml += `<p><strong>From:</strong> ${attrs.from}</p>`;
                                    infoHtml += `<p><strong>To:</strong> ${attrs.to}</p>`;
                                    infoHtml += `<p><strong>Type:</strong> ${attrs.type}</p>`;
                                }
                                
                                document.getElementById("nodeInfo").innerHTML = infoHtml || "<p>Click on nodes for details</p>";
                            }
                        });
                    });
                    
                    // Add keyboard shortcuts for view control
                    view.on("key-down", function(event) {
                        if (event.key === "r" || event.key === "R") {
                            // Reset view to show all
                            view.goTo(nodeLayer.graphics.concat(edgeLayer.graphics), {
                                padding: { top: 50, bottom: 50, left: 50, right: 400 }
                            });
                        } else if (event.key === "c" || event.key === "C") {
                            // Center on Bloomington
                            view.goTo({
                                center: cityCoords["Bloomington, CA"],
                                zoom: 11
                            });
                        }
                    });
                    
                } catch (error) {
                    console.error("Failed to initialize map:", error);
                    document.getElementById("loadingDiv").style.display = "none";
                    document.getElementById("errorDiv").style.display = "block";
                    document.getElementById("errorMessage").textContent = error.message;
                }
            }
            
            // Helper function to convert hex to RGB
            function hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? [
                    parseInt(result[1], 16),
                    parseInt(result[2], 16),
                    parseInt(result[3], 16)
                ] : [128, 128, 128];
            }
            
            // Helper function to convert hex to RGBA
            function hexToRgba(hex, alpha) {
                const rgb = hexToRgb(hex);
                return [...rgb, alpha];
            }

            // Start the application
            initializeMap();
        });
    </script>
</body>
</html> 
